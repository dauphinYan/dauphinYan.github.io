<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>赛尔号逆向：封包分析 - Orca丶的博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Orca丶的博客"><meta name="msapplication-TileImage" content="/img/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Orca丶的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="赛尔号封包抓取与分析。"><meta property="og:type" content="blog"><meta property="og:title" content="赛尔号逆向：封包分析"><meta property="og:url" content="https://github.com/dauphinYan/dauphinYan.github.io.git/2025/07/03/game-reversing/network-protocol-reversing/"><meta property="og:site_name" content="Orca丶的博客"><meta property="og:description" content="赛尔号封包抓取与分析。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog-1314504743.cos.ap-nanjing.myqcloud.com/image-20250703234524740.png"><meta property="og:image" content="https://blog-1314504743.cos.ap-nanjing.myqcloud.com/image-20250704105801081.png"><meta property="og:image" content="https://blog-1314504743.cos.ap-nanjing.myqcloud.com/image-20250704200337930.png"><meta property="og:image" content="https://blog-1314504743.cos.ap-nanjing.myqcloud.com/image-20250704202111919.jpg"><meta property="og:image" content="https://blog-1314504743.cos.ap-nanjing.myqcloud.com/wechat_2025-07-08_114622_738.png"><meta property="og:image" content="https://blog-1314504743.cos.ap-nanjing.myqcloud.com/image-20250704232253744.jpg"><meta property="og:image" content="https://blog-1314504743.cos.ap-nanjing.myqcloud.com/image-20250704232406825.jpg"><meta property="article:published_time" content="2025-07-03T07:47:54.000Z"><meta property="article:modified_time" content="2025-08-13T15:24:41.835Z"><meta property="article:author" content="Orca丶"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://blog-1314504743.cos.ap-nanjing.myqcloud.com/image-20250703234524740.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://github.com/dauphinYan/dauphinYan.github.io.git/2025/07/03/game-reversing/network-protocol-reversing/"},"headline":"赛尔号逆向：封包分析","image":["https://blog-1314504743.cos.ap-nanjing.myqcloud.com/image-20250703234524740.png","https://blog-1314504743.cos.ap-nanjing.myqcloud.com/image-20250704105801081.png","https://blog-1314504743.cos.ap-nanjing.myqcloud.com/image-20250704200337930.png","https://blog-1314504743.cos.ap-nanjing.myqcloud.com/image-20250704202111919.jpg","https://blog-1314504743.cos.ap-nanjing.myqcloud.com/wechat_2025-07-08_114622_738.png","https://blog-1314504743.cos.ap-nanjing.myqcloud.com/image-20250704232253744.jpg","https://blog-1314504743.cos.ap-nanjing.myqcloud.com/image-20250704232406825.jpg"],"datePublished":"2025-07-03T07:47:54.000Z","dateModified":"2025-08-13T15:24:41.835Z","author":{"@type":"Person","name":"Orca丶"},"publisher":{"@type":"Organization","name":"Orca丶的博客","logo":{"@type":"ImageObject","url":"https://github.com/img/favicon.ico"}},"description":"赛尔号封包抓取与分析。"}</script><link rel="canonical" href="https://github.com/dauphinYan/dauphinYan.github.io.git/2025/07/03/game-reversing/network-protocol-reversing/"><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/favicon.ico" alt="Orca丶的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/dauphinYan"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-07-03T07:47:54.000Z" title="2025/7/3 15:47:54">2025-07-03</time>发表</span><span class="level-item"><time dateTime="2025-08-13T15:24:41.835Z" title="2025/8/13 23:24:41">2025-08-13</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%B5%9B%E5%B0%94%E5%8F%B7%E9%80%86%E5%90%91/">赛尔号逆向</a></span></div></div><h1 class="title is-3 is-size-4-mobile">赛尔号逆向：封包分析</h1><div class="content"><p>文章内容完善中……</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>作者是一名赛尔号PVP玩家，最近胜率一直不高，因此决定制作一款巅峰辅助工具。</p>
<p>本人此前从未接触过网络通信这一块，基本是现学现用，因此可能会存在部分问题，还望大佬们指出！</p>
<p>本文所用工具如下：</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Fiddler Classic</td>
<td>抓包工具</td>
</tr>
<tr>
<td>JPEXS Free Flash Decompiler</td>
<td>Flash文件反编译工具</td>
</tr>
<tr>
<td>x64dbg</td>
<td>程序调试器</td>
</tr>
</tbody></table>
<p>项目开源地址：<a href="https://github.com/dauphinYan/SeerAssistant">https://github.com/dauphinYan/SeerAssistant</a></p>
<h3 id="获取Flash文件并反编译"><a href="#获取Flash文件并反编译" class="headerlink" title="获取Flash文件并反编译"></a>获取Flash文件并反编译</h3><p>本阶段用到的工具：Fiddler Classic、JPEXS Free Flash Decompiler。</p>
<p>这部分暂时跳过…（可以参考文末链接）</p>
<p>反编译成功后，我们会得到下述四个文件夹：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Client</span><br><span class="line">RobotAppDLL</span><br><span class="line">RobotCoreDLL</span><br><span class="line">TaomeeLibrary</span><br></pre></td></tr></table></figure>

<h3 id="尝试读源码！"><a href="#尝试读源码！" class="headerlink" title="尝试读源码！"></a>尝试读源码！</h3><h4 id="通信数据解密"><a href="#通信数据解密" class="headerlink" title="通信数据解密"></a>通信数据解密</h4><p>我们可以在前面反编译得到的<code>TaomeeLibrary</code>文件夹中搜索<code>socket</code>，毕竟网络通信都需要使用到<code>socket</code>，所以可以使用这种方法快速接近目标。然后，我们发现了十分显眼的<code>MDecrypt.as</code>，赶快进去瞧瞧！</p>
<img src="https://blog-1314504743.cos.ap-nanjing.myqcloud.com/image-20250703234524740.png" alt="image-20250703234524740" style="zoom:67%;" />

<p>可以看到<code>MDecrypt.as</code>的主要函数为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> function <span class="title">MDecrypt</span><span class="params">(param1:ByteArray, param2:<span class="type">int</span>, param3:ByteArray)</span> : void</span></span><br></pre></td></tr></table></figure>

<p>因此我们需要弄清传入的三个参数对应的含义。</p>
<p>同样，在<code>TameeLibrary</code>文件夹中搜索<code>MDecrypt(</code>，这里有一个技巧，在末尾添加<code>(</code>就可以快速找到该函数在哪里实现以及调用。</p>
<img src="https://blog-1314504743.cos.ap-nanjing.myqcloud.com/image-20250704105801081.png" alt="image-20250704105801081" style="zoom:67%;" />

<p>现在可以清楚的看到在<code>MessageEncrypt.as</code>中有调用，我们进去看看。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> NO_ENCRYPT_LEN:<span class="built_in">int</span> = <span class="number">4</span>;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> function <span class="title">decrypt</span>(<span class="params">inData:ByteArray</span>) : ByteArray</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="keyword">var</span> inLen:<span class="built_in">int</span> = inData.readUnsignedInt() - NO_ENCRYPT_LEN;</span><br><span class="line">     <span class="keyword">var</span> outData:ByteArray = <span class="keyword">new</span> ByteArray();</span><br><span class="line">     outData.writeUnsignedInt(<span class="number">0</span>);</span><br><span class="line">     MDecrypt(inData,inLen,outData);</span><br><span class="line">     outData.position = <span class="number">0</span>;</span><br><span class="line">     outData.writeUnsignedInt(outData.length);</span><br><span class="line">     outData.position = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">return</span> outData;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>通过这个函数实现，可以大胆猜测：</p>
<ul>
<li><code>InData</code>：传入的数据包。</li>
<li><code>inLen</code>：真正需要解密的部分。</li>
<li><code>outData</code>：解密后的数据包。</li>
<li><code>NO_ENCRYPT_LEN</code>：记录数据包的长度信息。（这里大胆猜测，前四字节为包体长度）</li>
</ul>
<blockquote>
<p>为什么这么猜测呢？因为数据在传递的过程中，数据不是逐字节的发送的，而是以数据包的形式成批发送，那么发送方为了让接收方区分接收到的数据，通常会在数据包头部保留明文片段用于标识数据包的长度。</p>
</blockquote>
<p><code>MDecrypt.as</code>源码可读性比较差，有兴趣可以自行阅读分析，使用C++重写的源码可见下方。</p>
<p>C++重写后的解密源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">uint8_t</span>&gt; <span class="title">Cryptor::Decrypt</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">uint8_t</span>&gt; &amp;Cipher)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> len = Cipher.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span> || Key.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算旋转量</span></span><br><span class="line">    <span class="type">int</span> result = Key[(len - <span class="number">1</span>) % Key.<span class="built_in">size</span>()] * <span class="number">13</span> % len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 环形右移 result 个字节</span></span><br><span class="line">    std::vector&lt;<span class="type">uint8_t</span>&gt; rotated = <span class="built_in">Merge</span>(</span><br><span class="line">        <span class="built_in">Slice</span>(Cipher, len - result, len),</span><br><span class="line">        <span class="built_in">Slice</span>(Cipher, <span class="number">0</span>, len - result));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右移/左移组合恢复原始字节序列（去掉最后一个字节）</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">uint8_t</span>&gt; <span class="title">plain</span><span class="params">(len - <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        plain[i] = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;((rotated[i] &gt;&gt; <span class="number">5</span>) | (rotated[i + <span class="number">1</span>] &lt;&lt; <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异或解密</span></span><br><span class="line">    <span class="type">size_t</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> NeedBecomeZero = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; plain.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">1</span> &amp;&amp; NeedBecomeZero)</span><br><span class="line">        &#123;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            NeedBecomeZero = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == Key.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            NeedBecomeZero = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        plain[i] = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(plain[i] ^ Key[j]);</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> plain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过有一点需要注意，在官方的源码中</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_loc11_ = CModule.mallocString(getDefinitionByName(<span class="string">&quot;com.robot.core.net.SocketConnection&quot;</span>).key);</span><br></pre></td></tr></table></figure>

<p><code>_loc11_</code>在很多处都有参与运算，因此我们需要弄清楚这个值是怎么来的。</p>
<p>根据路径找到<code>SocketConnection.as</code>，发现关键函数<code>key()</code>：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> _encryptKeyStringArr:Array;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> function <span class="keyword">get</span> <span class="title">key</span>() : String</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">var</span> _loc2_:<span class="built_in">int</span> = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">var</span> _loc3_:String = <span class="literal">null</span>;</span><br><span class="line"> <span class="keyword">var</span> _loc1_:String = <span class="string">&quot;&quot;</span>;</span><br><span class="line"> <span class="keyword">if</span>(_encryptKeyStringArr == <span class="literal">null</span>)</span><br><span class="line"> &#123;</span><br><span class="line">    _loc1_ = <span class="string">&quot;!crAckmE4nOthIng:-)&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">    _loc2_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(_loc2_ &lt; _encryptKeyStringArr.length)</span><br><span class="line">    &#123;</span><br><span class="line">       _loc3_ = StringUtil.replace(_encryptKeyStringArr[_loc2_],<span class="string">&quot;*&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">       _loc1_ += _loc3_;</span><br><span class="line">       _loc2_++;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> _loc1_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难知道，默认情况下<code>key</code>的值为<code>!crAckmE4nOthIng:-)</code>，这个密钥看着很像某些单词的缩写，简单解读一下。</p>
<ul>
<li><code>crAckmE</code>：Crack me.</li>
<li><code>4</code>：for.</li>
<li><code>nOthIng</code>：Nothing.</li>
</ul>
<p>连起来也就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Crack me for nothing.   试着破解我吧，反正也没啥有用的东西😊</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里感谢”圆圆圆“提供的解释。</p>
</blockquote>
<p>显然，这个<code>key</code>在后面肯定会被修改，我们在这个文件中又找到的修改函数：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> function <span class="title">setEncryptKeyStringArr</span>(<span class="params">param1:Array</span>) : <span class="keyword">void</span></span></span><br><span class="line">&#123;</span><br><span class="line"> _encryptKeyStringArr = param1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此在文件夹中搜索<code>setEncryptKeyStringArr(</code>，得到结果如下图所示：</p>
<img src="https://blog-1314504743.cos.ap-nanjing.myqcloud.com/image-20250704200337930.png" alt="image-20250704200337930" style="zoom:67%;" />

<p>只找到一处该方法的调用，和我们的预期有所差距：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> function <span class="title">onSocketClose</span>(<span class="params">param1:Event</span>) : <span class="keyword">void</span></span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">var</span> <span class="keyword">event</span>:Event = param1;</span><br><span class="line">   DebugTrace.show(<span class="string">&quot;////////////////////////////////////////////////////////////////////////////////\r//\r//\t\t\t\t&quot;</span> + <span class="string">&quot;socket was closed\r//\r////////////////////////////////////////////////////////////////////////////////&quot;</span>);</span><br><span class="line">   <span class="keyword">try</span></span><br><span class="line">   &#123;</span><br><span class="line">      SocketConnection.mainSocket.removeEventListener(Event.CLOSE,onSocketClose);</span><br><span class="line">      SocketConnection.setEncryptKeyStringArr(<span class="literal">null</span>);</span><br><span class="line">      SocketConnectionHelper.clear();</span><br><span class="line">      ModuleManager.hideAllModule();</span><br><span class="line">      <span class="keyword">if</span>(login10004)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      Alarm.show(<span class="string">&quot;此次连接已经断开，请重新登录&quot;</span>,function():<span class="keyword">void</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">if</span>(ExternalInterface.available)</span><br><span class="line">         &#123;</span><br><span class="line">            navigateToURL(<span class="keyword">new</span> URLRequest(<span class="string">&quot;javascript:window.location.reload();&quot;</span>),<span class="string">&quot;_self&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">            navigateToURL(<span class="keyword">new</span> URLRequest(<span class="string">&quot;https://seer.61.com&quot;</span>),<span class="string">&quot;_self&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">false</span>,LevelManager.stage);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span>(e:Error)</span><br><span class="line">   &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这部分发生在与游戏服务器断开的阶段，并没有达到修改<code>key</code>的目的，现在就比较麻烦了。</p>
<p>既然如此，那我们先去开一把休息一下，羁绊后的伽马强度还是太爆炸了……</p>
<img src="https://blog-1314504743.cos.ap-nanjing.myqcloud.com/image-20250704202111919.jpg" alt="image-20250704202111919" style="zoom: 33%;" />

<h4 id="数据包格式解析"><a href="#数据包格式解析" class="headerlink" title="数据包格式解析"></a>数据包格式解析</h4><p>在找<code>key</code>之前呢，可以先看看官方是如何解析数据包的，前面我们知道<code>MessageEncrypt.as</code>有一个<code>decrypt(</code>函数，很明显，这是一个套壳函数，没有解析数据的具体实现。因此文件夹中搜索<code>decrypt(</code>，可以定位到<code>SocketEncryptImpl.as</code>，其中包含一个函数：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> function <span class="title">onData</span>(<span class="params">e:Event</span>) : <span class="keyword">void</span></span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">var</span> msgLen:<span class="built_in">int</span> = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">var</span> ba:ByteArray = <span class="literal">null</span>;</span><br><span class="line">   DebugTrace.show(<span class="string">&quot;socket onData handler....................&quot;</span>);</span><br><span class="line">   <span class="keyword">this</span>._chunkBuffer.clear();</span><br><span class="line">   <span class="keyword">if</span>(<span class="keyword">this</span>._tempBuffer.length &gt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">this</span>._tempBuffer.position = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">this</span>._tempBuffer.readBytes(<span class="keyword">this</span>._chunkBuffer,<span class="number">0</span>,<span class="keyword">this</span>._tempBuffer.length);</span><br><span class="line">      <span class="keyword">this</span>._tempBuffer.clear();</span><br><span class="line">   &#125;</span><br><span class="line">   readBytes(<span class="keyword">this</span>._chunkBuffer,<span class="keyword">this</span>._chunkBuffer.length,bytesAvailable);</span><br><span class="line">   <span class="keyword">this</span>._chunkBuffer.position = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(<span class="keyword">this</span>._chunkBuffer.bytesAvailable &gt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>._chunkBuffer.bytesAvailable &gt; MSG_FIRST_TOKEN_LEN)</span><br><span class="line">      &#123;</span><br><span class="line">         msgLen = <span class="keyword">this</span>._chunkBuffer.readUnsignedInt() - MSG_FIRST_TOKEN_LEN;</span><br><span class="line">         <span class="keyword">if</span>(<span class="keyword">this</span>._chunkBuffer.bytesAvailable &gt;= msgLen)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="keyword">this</span>._chunkBuffer.position -= MSG_FIRST_TOKEN_LEN;</span><br><span class="line">            ba = MessageEncrypt.decrypt(<span class="keyword">this</span>._chunkBuffer);			<span class="comment">// 在这里！</span></span><br><span class="line">            <span class="keyword">this</span>.parseData(ba);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">            <span class="keyword">this</span>._chunkBuffer.position -= MSG_FIRST_TOKEN_LEN;</span><br><span class="line">            <span class="keyword">this</span>._chunkBuffer.readBytes(<span class="keyword">this</span>._tempBuffer,<span class="number">0</span>,<span class="keyword">this</span>._chunkBuffer.bytesAvailable);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">this</span>._chunkBuffer.readBytes(<span class="keyword">this</span>._tempBuffer,<span class="number">0</span>,<span class="keyword">this</span>._chunkBuffer.bytesAvailable);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在解密函数的下方，有一个<code>ParseData</code>函数，翻译过来就是”解析数据“。那么我们定位到那里去：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">const</span> HEAD_LENGTH:<span class="built_in">uint</span> = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> function <span class="title">parseData</span>(<span class="params">data:ByteArray</span>) : <span class="keyword">void</span></span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="keyword">var</span> info:ByteArray = <span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">var</span> tmfClass:Class = <span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">this</span>._packageLen = data.readUnsignedInt();</span><br><span class="line">     <span class="keyword">if</span>(<span class="keyword">this</span>._packageLen &lt; HEAD_LENGTH || <span class="keyword">this</span>._packageLen &gt; PACKAGE_MAX)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">this</span>.readDataError(<span class="number">0</span>);</span><br><span class="line">        dispatchEvent(<span class="keyword">new</span> SocketErrorEvent(SocketErrorEvent.ERROR,<span class="literal">null</span>));</span><br><span class="line">        data.readBytes(<span class="keyword">new</span> ByteArray());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">this</span>._headInfo = <span class="keyword">new</span> HeadInfo(data);</span><br><span class="line">     <span class="keyword">if</span>(<span class="keyword">this</span>._headInfo.cmdID == <span class="number">1001</span>)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">this</span>._result = <span class="keyword">this</span>._headInfo.result;</span><br><span class="line">     &#125;</span><br><span class="line">     DebugTrace.show(<span class="string">&quot;&lt;&lt;Socket[&quot;</span> + <span class="keyword">this</span>.ip + <span class="string">&quot;:&quot;</span> + <span class="keyword">this</span>.port.toString() + <span class="string">&quot;][cmdID:&quot;</span> + <span class="keyword">this</span>._headInfo.cmdID + <span class="string">&quot;]&quot;</span>,getCmdLabel(<span class="keyword">this</span>._headInfo.cmdID));</span><br><span class="line">     <span class="keyword">if</span>(<span class="keyword">this</span>._headInfo.result &gt; <span class="number">1000</span>)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">this</span>.readDataError(<span class="keyword">this</span>._headInfo.cmdID);</span><br><span class="line">        <span class="keyword">this</span>.dispatchError(<span class="keyword">this</span>._headInfo.cmdID,<span class="keyword">this</span>._headInfo);</span><br><span class="line">        dispatchEvent(<span class="keyword">new</span> SocketErrorEvent(SocketErrorEvent.ERROR,<span class="keyword">this</span>._headInfo));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">this</span>._dataLen = <span class="keyword">this</span>._packageLen - HEAD_LENGTH;</span><br><span class="line">     <span class="keyword">if</span>(<span class="keyword">this</span>._dataLen == <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">this</span>.readDataError(<span class="keyword">this</span>._headInfo.cmdID);</span><br><span class="line">        <span class="keyword">this</span>.dispatchCmd(<span class="keyword">this</span>._headInfo.cmdID,<span class="keyword">this</span>._headInfo,<span class="literal">null</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">        info = <span class="keyword">new</span> ByteArray();</span><br><span class="line">        data.readBytes(info,<span class="number">0</span>,<span class="keyword">this</span>._dataLen);</span><br><span class="line">        tmfClass = TMF.getClass(<span class="keyword">this</span>._headInfo.cmdID);</span><br><span class="line">        <span class="keyword">this</span>.readDataError(<span class="keyword">this</span>._headInfo.cmdID);</span><br><span class="line">        <span class="keyword">this</span>.dispatchCmd(<span class="keyword">this</span>._headInfo.cmdID,<span class="keyword">this</span>._headInfo,<span class="keyword">new</span> tmfClass(info));</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Debug输出与<code>_headInfo</code>有关，那么同样的方式，我们定位到<code>HeadInfo</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> function <span class="title">HeadInfo</span>(<span class="params">headData:IDataInput</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   super();</span><br><span class="line">   <span class="keyword">this</span>._version = headData.readUTFBytes(<span class="number">1</span>);		<span class="comment">// 版本号，1字节</span></span><br><span class="line">   <span class="keyword">this</span>._cmdID = headData.readUnsignedInt();		<span class="comment">// 命令号，4字节</span></span><br><span class="line">   <span class="keyword">this</span>._userID = headData.readUnsignedInt();		<span class="comment">// 用户号，4字节</span></span><br><span class="line">   <span class="keyword">this</span>._result = headData.readInt();				<span class="comment">// 序列号，4字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次阅读代码，现在封包的结构就十分明确了：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封包长度, 4字节|版本号，1字节|命令号，4字节|用户号，4字节|序列号，4字节|包体数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>._packageLen = data.readUnsignedInt();			<span class="comment">// 封包长度, 4字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>._headInfo = <span class="keyword">new</span> HeadInfo(data);				<span class="comment">// 头部信息，13字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>._dataLen = <span class="keyword">this</span>._packageLen - HEAD_LENGTH;		<span class="comment">// 包体长度</span></span><br></pre></td></tr></table></figure>

<p>这里补充一下，我们会发现在<code>parseData()</code>函数中，有一处命令ID的判断：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>._headInfo.cmdID == <span class="number">1001</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">this</span>._result = <span class="keyword">this</span>._headInfo.result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以尝试在文件夹中搜索<code>cmdID</code>，接着我们会发现：</p>
<p><img src="https://blog-1314504743.cos.ap-nanjing.myqcloud.com/wechat_2025-07-08_114622_738.png" alt="wechat_2025-07-08_114622_738"></p>
<p>这里有一个<code>cmdID</code>的值为<code>41129</code>，接着我们继续搜索<code>41129</code>，然后我们会找到<code>CommandID.as</code>文件夹，这里面就包含了所有命令的ID，下面截取部分内容：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.robot.core</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CommandID</span></span><br><span class="line">   &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">const</span> LOADING_TIME_STAT:<span class="built_in">uint</span> = <span class="number">9303</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">const</span> GET_PET_TOWER_ACHIEVE:<span class="built_in">uint</span> = <span class="number">3453</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">const</span> RECEIVE_PRANKSTER_REWARD:<span class="built_in">uint</span> = <span class="number">1014</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">const</span> TOPFIGHT_RANKING_LIST:<span class="built_in">uint</span> = <span class="number">2459</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">const</span> TOPFIGHT_GET_AWARD:<span class="built_in">uint</span> = <span class="number">9374</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">const</span> TOPFIGHT_WEEK_WIN:<span class="built_in">uint</span> = <span class="number">2532</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">const</span> TOPFIGHT_BEYOND:<span class="built_in">uint</span> = <span class="number">2567</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到这个文件的方法有很多，这里只列举其中一种，最开始找到这个文件的方法我忘记了，上述方法是临时找的。</p>
<h4 id="找出修改Key的位置"><a href="#找出修改Key的位置" class="headerlink" title="找出修改Key的位置"></a>找出修改Key的位置</h4><p>回到这里，既然找不到修改<code>key</code>的位置，我们不妨先使用当前已经得到的解密算法对接收到的数据进行解密，这里选用<code>Hook</code>注入的方法（现在不清楚不用着急，后面会介绍的），解密得到的信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[2025-07-03 15:22:54.849] [ThreadID 0xfb8] [Temp] [Hooked send] Parsed Data:[Length=17 Version=49 CmdID=111 Cmd=———— UserID=123456789 SN=0 BodySize=0] </span><br><span class="line">[2025-07-03 15:22:54.874] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=21 Version=0 CmdID=111 Cmd=———— UserID=123456789 SN=0 BodySize=4] Body=[00 00 00 00 ]</span><br><span class="line">[2025-07-03 15:22:54.878] [ThreadID 0xfb8] [Temp] [Hooked send] Parsed Data:[Length=37 Version=49 CmdID=109 Cmd=SYS_ROLE UserID=123456789 SN=0 BodySize=20] Body=[a4 0e a7 cc 84 21 87 f2 f6 91 51 9a 7a 0e b7 6e ...]</span><br><span class="line">[2025-07-03 15:22:54.903] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=21 Version=0 CmdID=109 Cmd=SYS_ROLE UserID=123456789 SN=0 BodySize=4] Body=[00 00 00 00 ]</span><br><span class="line">[2025-07-03 15:22:54.905] [ThreadID 0xfb8] [Temp] [Hooked send] Parsed Data:[Length=37 Version=49 CmdID=105 Cmd=COMMEND_ONLINE UserID=123456789 SN=0 BodySize=20] Body=[a4 0e a7 cc 84 21 87 f2 f6 91 51 9a 7a 0e b7 6e ...]</span><br><span class="line">[2025-07-03 15:22:54.934] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=561 Version=0 CmdID=105 Cmd=COMMEND_ONLINE UserID=123456789 SN=0 BodySize=544] Body=[00 00 0b 99 00 00 00 03 00 79 ec 33 00 00 00 02 ...]</span><br><span class="line">[2025-07-03 15:23:06.439] [ThreadID 0xfb8] [Temp] [Hooked send] Parsed Data:[Length=141 Version=49 CmdID=1001 Cmd=LOGIN_IN UserID=123456789 SN=202 BodySize=124] Body=[a4 0e a7 cc 84 21 87 f2 f6 91 51 9a 7a 0e b7 6e ...]</span><br><span class="line">[2025-07-03 15:23:06.989] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=171 Version=62 CmdID=8002 Cmd=SYSTEM_MESSAGE UserID=123456789 SN=0 BodySize=154] Body=[00 01 88 43 68 66 2f da 00 00 00 8e 20 e7 b2 be ...]</span><br><span class="line">[2025-07-03 15:23:06.995] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=171 Version=62 CmdID=8002 Cmd=SYSTEM_MESSAGE UserID=123456789 SN=0 BodySize=154] Body=[00 01 88 43 68 66 2f da 00 00 00 8e 20 e7 b2 be ...]</span><br><span class="line">[2025-07-03 15:23:06.996] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=113 Version=62 CmdID=8002 Cmd=SYSTEM_MESSAGE UserID=123456789 SN=0 BodySize=96] Body=[00 01 88 43 68 66 2f da 00 00 00 54 e5 a6 82 e6 ...]</span><br><span class="line">[2025-07-03 15:23:06.996] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=129 Version=62 CmdID=8002 Cmd=SYSTEM_MESSAGE UserID=123456789 SN=0 BodySize=112] Body=[00 00 00 03 68 66 2f da 00 00 00 64 20 e4 bd a0 ...]</span><br><span class="line">[2025-07-03 15:23:06.997] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=25 Version=62 CmdID=3452 Cmd=LASTVALUE UserID=123456789 SN=0 BodySize=8] Body=[00 00 00 7f 00 00 00 32 ]</span><br><span class="line">[2025-07-03 15:23:06.997] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=25 Version=62 CmdID=3452 Cmd=LASTVALUE UserID=123456789 SN=0 BodySize=8] Body=[00 00 00 63 00 00 00 02 ]</span><br><span class="line">[2025-07-03 15:23:06.997] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=25 Version=62 CmdID=2394 Cmd=PET_BOOK_UPDATE UserID=123456789 SN=0 BodySize=8] Body=[00 00 05 1c 00 00 00 01 ]</span><br><span class="line">[2025-07-03 15:23:06.998] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=25 Version=62 CmdID=3452 Cmd=LASTVALUE UserID=123456789 SN=0 BodySize=8] Body=[00 00 00 2b 00 00 00 3c ]</span><br><span class="line">[2025-07-03 15:23:06.998] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=25 Version=62 CmdID=3452 Cmd=LASTVALUE UserID=123456789 SN=0 BodySize=8] Body=[00 00 00 2b 00 00 00 00 ]</span><br><span class="line">[2025-07-03 15:23:06.998] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=25 Version=62 CmdID=3452 Cmd=LASTVALUE UserID=123456789 SN=0 BodySize=8] Body=[00 00 00 2b 00 00 01 54 ]</span><br><span class="line">[2025-07-03 15:23:06.998] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=25 Version=62 CmdID=3452 Cmd=LASTVALUE UserID=123456789 SN=0 BodySize=8] Body=[00 00 00 2b 00 00 08 8b ]</span><br><span class="line">[2025-07-03 15:23:06.999] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=25 Version=62 CmdID=3452 Cmd=LASTVALUE UserID=123456789 SN=0 BodySize=8] Body=[00 00 00 2b 00 00 0a 31 ]</span><br><span class="line">[2025-07-03 15:23:07.031] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=3413 Version=62 CmdID=1001 Cmd=LOGIN_IN UserID=123456789 SN=46 BodySize=3396] Body=[0d b2 32 92 4d 71 dc 79 e7 89 9b e6 8e 92 00 00 ...]</span><br></pre></td></tr></table></figure>

<p>这里只截取正常的部分（<code>UserID</code>我就用”123456”代替了），从接收到<code>LOGIN_IN</code>指令以后，数据变得非常奇怪，也就是说，<code>key</code>值的改变发生在接收到<code>LOGIN_IN</code>指令后！</p>
<p>在文件夹中搜索<code>LOGIN_IN</code>，结果不多，挨个查看下，最后锁定在<code>MainEntry.as</code>：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> function <span class="title">onLogin</span>(<span class="params">param1:SocketEvent</span>) : <span class="keyword">void</span></span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(SaveUserInfo.loginIDInfo.loginType == <span class="number">3</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      StatManager.sendStat2014(<span class="string">&quot;手机验证码注册/登录&quot;</span>,<span class="string">&quot;【手机验证码登录玩家】登录ONLINE服&quot;</span>,<span class="string">&quot;手机验证码&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(MainManager.isNewUser)</span><br><span class="line">   &#123;</span><br><span class="line">      StatManager.sendStat2014(<span class="string">&quot;_newtrans_&quot;</span>,<span class="string">&quot;fOnlineSucc&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(!isReconnect)</span><br><span class="line">   &#123;</span><br><span class="line">      SocketConnection.removeCmdListener(CommandID.LOGIN_IN,onLogin);</span><br><span class="line">      EventManager.addEventListener(RobotEvent.CREATED_ACTOR,onCreatedActor);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      SocketConnection.removeCmdListener(CommandID.RELOGIN_IN,onLogin);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> _loc2_:<span class="built_in">int</span> = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span>(isReconnect)</span><br><span class="line">   &#123;</span><br><span class="line">      _loc2_ = <span class="built_in">int</span>(MainManager.actorInfo.mapID);</span><br><span class="line">   &#125;</span><br><span class="line">   MainManager.setup(param1.data,isReconnect,_loc2_);</span><br><span class="line">   <span class="keyword">var</span> _loc3_:ByteArray = param1.data <span class="keyword">as</span> ByteArray;</span><br><span class="line">   <span class="keyword">var</span> _loc4_:<span class="built_in">int</span> = <span class="built_in">int</span>(_loc3_.readUnsignedInt());</span><br><span class="line">   initKey(_loc4_);</span><br><span class="line">   MainEntry.login10004 = <span class="literal">false</span>;</span><br><span class="line">   LevelManager.openMouseEvent();</span><br><span class="line">   <span class="keyword">if</span>(isReconnect)</span><br><span class="line">   &#123;</span><br><span class="line">      MainManager.reconnectRequest();</span><br><span class="line">      EventManager.dispatchEvent(<span class="keyword">new</span> Event(ReconnectCompleteController.RECONNECTSUC));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(!isReconnect)</span><br><span class="line">   &#123;</span><br><span class="line">      MapConfig.setup();</span><br><span class="line">      MapSeatPointConfig.setup();</span><br><span class="line">   &#125;</span><br><span class="line">   sendSystemInfo();</span><br><span class="line">   SocketConnection.send(<span class="number">1022</span>,<span class="number">86066824</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们会发现一个特别显眼的函数：<code>initKey(_loc4_)</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> function <span class="title">initKey</span>(<span class="params">param1:<span class="built_in">int</span></span>) : <span class="keyword">void</span></span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">var</span> _loc2_:String = <span class="string">&quot;c&amp;o&amp;m.--rob-ot.c--o-r-e.&amp;n-et.S-oc-ke-t&amp;C-on-n-e-c-t-i-on&quot;</span>;</span><br><span class="line">   <span class="keyword">var</span> _loc3_:* = <span class="string">&quot;s*e*tE&amp;&amp;&amp;n*c&quot;</span>;</span><br><span class="line">   _loc3_ += <span class="string">&quot;r*yp*t&amp;&amp;&amp;&amp;Ke*yS*tr*i&amp;n&amp;&amp;g*Arr&quot;</span>;</span><br><span class="line">   _loc2_ = StringUtil.replace(_loc2_,<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">   _loc2_ = StringUtil.replace(_loc2_,<span class="string">&quot;&amp;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">   _loc3_ = StringUtil.replace(_loc3_,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">   _loc3_ = StringUtil.replace(_loc3_,<span class="string">&quot;&amp;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">   param1 ^= MainManager.actorInfo.userID;</span><br><span class="line">   <span class="keyword">var</span> _loc4_:String = MD5.hash(param1 + <span class="string">&quot;&quot;</span>);</span><br><span class="line">   <span class="keyword">var</span> _loc5_:* = MainManager.actorInfo.userID + <span class="string">&quot;&quot;</span>;</span><br><span class="line">   <span class="keyword">var</span> _loc6_:Array = [];</span><br><span class="line">   <span class="keyword">var</span> _loc7_:<span class="built_in">int</span> = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(_loc7_ &lt; <span class="number">10</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      _loc6_[_loc7_] = <span class="string">&quot;*&quot;</span> + _loc4_.charAt(_loc7_) + <span class="string">&quot;*&quot;</span>;</span><br><span class="line">      _loc7_++;</span><br><span class="line">   &#125;</span><br><span class="line">   getDefinitionByName(_loc2_)[_loc3_](_loc6_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理一下，就可以的得到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_loc2_ = &quot;com.robot.core.net.SocketConnection&quot;;</span><br><span class="line">_loc3_ = &quot;setEncryptKeyStringArr&quot;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种避免直接通过字符串搜索的方法学到了！</p>
</blockquote>
<p>发现没，<code>_loc3_</code>就是我们前面只能找到一处调用的方法<code>setEncryptKeyStringArr</code>。</p>
<h3 id="制作我们自己的Hook"><a href="#制作我们自己的Hook" class="headerlink" title="制作我们自己的Hook"></a>制作我们自己的Hook</h3><h4 id="本文中有什么作用？"><a href="#本文中有什么作用？" class="headerlink" title="本文中有什么作用？"></a>本文中有什么作用？</h4><p>在本文中，我们的最终目的是对网络通信中的数据包进行解密，因此如何捕获数据非常重要。为了实现这一目的，就需要请出本节主角：Hook！</p>
<h4 id="什么是Hook"><a href="#什么是Hook" class="headerlink" title="什么是Hook?"></a>什么是Hook?</h4><p>Hook，又称钩子，是一种能够拦截和修改函数或方法的技术。它允许开发者在不修改原有的代码前提下，修改程序的行为。</p>
<p>例如在网络通信中，我们通过我们通过<strong>Hook</strong>拦截网络API的调用，例如<code>send</code>、<code>recv</code>等，这样就可以捕获网络通信中的一段<strong>十六进制</strong>数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3c 3f 78 6d 6c 20 76 65 72 73 69 6f 6e 3d 22 31 2e 30 22 3f 3e 3c 21 44 4f 43 54 59 50 45 20 63 72 6f 73 73 2d 64 6f 6d 61 69 6e 2d 70 6f 6c 69 63 79 3e 3c 63 72 6f 73 73 2d 64 6f 6d 61 69 6e 2d 70 6f 6c 69 63 79 3e 3c 61 6c 6c 6f 77 2d 61 63 63 65 73 73 2d 66 72 6f 6d 20 64 6f 6d 61 69 6e 3d 22 2a 22 20 74 6f 2d 70 6f 72 74 73 3d 22 2a 22 20 2f 3e 3c 2f 63 72 6f 73 73 2d 64 6f 6d 61 69 6e 2d 70 6f 6c 69 63 79 3e 00</span><br></pre></td></tr></table></figure>

<p>将其转换为<strong>ASCII字符</strong>就可以得到：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">cross-domain-policy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cross-domain-policy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">allow-access-from</span> <span class="attr">domain</span>=<span class="string">&quot;*&quot;</span> <span class="attr">to-ports</span>=<span class="string">&quot;*&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cross-domain-policy</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然了，这个肯定是我们不需要的数据。</p>
<p>总的来说，<strong>Hook</strong>在本文的作用就是捕获我们需要分析的数据包。</p>
<h4 id="Hook选择"><a href="#Hook选择" class="headerlink" title="Hook选择"></a>Hook选择</h4><p>一般情况下，<strong>Hook</strong>都是以<strong>DLL</strong>的形式注入到进程中，然后对进程进行修改，所以我们也需要制作<strong>DLL</strong>文件。</p>
<blockquote>
<p>考虑到使用Windows原生API实现Hook难度不小，因此本文采用第三方开源库<strong>MinHook</strong>。</p>
<p>链接：<a href="https://github.com/TsudaKageyu/minhook">https://github.com/TsudaKageyu/minhook</a></p>
</blockquote>
<p><strong>MinHook</strong>的实现就非常方便了，大致流程如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function">MH_STATUS WINAPI <span class="title">MH_Initialize</span><span class="params">(VOID)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建钩子 pTarget：需要替换的目标函数地址。 pDetour：我们自己创建的函数地址。 ppOriginal：用于保存原始函数指针（方便绕过Hook）</span></span><br><span class="line"><span class="function">MH_STATUS WINAPI <span class="title">MH_CreateHook</span><span class="params">(LPVOID pTarget, LPVOID pDetour, LPVOID *ppOriginal)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动钩子</span></span><br><span class="line"><span class="function">MH_STATUS WINAPI <span class="title">MH_EnableHook</span><span class="params">(LPVOID pTarget)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 关闭钩子</span></span></span><br><span class="line"><span class="function">MH_STATUS WINAPI <span class="title">MH_DisableHook</span><span class="params">(LPVOID pTarget)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 收工后的一些处理</span></span></span><br><span class="line"><span class="function">MH_STATUS WINAPI <span class="title">MH_Uninitialize</span><span class="params">(VOID)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="Hook初始化"><a href="#Hook初始化" class="headerlink" title="Hook初始化"></a>Hook初始化</h4><p>在初始化前呢，我们应当明确需要拦截的地方，这里就不得不提到<code>ws2_32.dll</code>这个文件了。</p>
<p><code>ws2_32.dll</code>是Windows Sockets API的实现，通常网络通信都会用到它，以<code>Flash</code>端为例，数据传输的过程中通常会调用<code>send</code>和<code>recv</code>方法，因此我们只需要拦截这两个方法即可。</p>
<p>根据<strong>MinHook</strong>提供的初始化办法，我们需要获取：</p>
<ul>
<li><code>pTarget</code>：需要替换的目标函数地址。  </li>
<li><code>pDetour</code>：我们自己创建的函数地址。</li>
<li><code>ppOriginal</code>：用于保存原始函数指针（方便绕过Hook）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先加载ws2_32.dll</span></span><br><span class="line">HMODULE ws2_32 = <span class="literal">nullptr</span>;</span><br><span class="line">ws2_32 = <span class="built_in">GetModuleHandleW</span>(<span class="string">L&quot;ws2_32&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取函数地址</span></span><br><span class="line">LPVOID targetSend = <span class="built_in">reinterpret_cast</span>&lt;LPVOID&gt;(<span class="built_in">GetProcAddress</span>(ws2_32, <span class="string">&quot;send&quot;</span>));</span><br><span class="line">LPVOID targetRecv = <span class="built_in">reinterpret_cast</span>&lt;LPVOID&gt;(<span class="built_in">GetProcAddress</span>(ws2_32, <span class="string">&quot;recv&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义原始函数指针</span></span><br><span class="line"><span class="keyword">decltype</span>(&amp;recv) originalRecv = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">decltype</span>(&amp;send) originalSend = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>别着急，捕获数据前还需要了解一个知识点：<strong>管道</strong>。</p>
<p>先明确我们的需求：</p>
<p>假设，我们创建了一个DLL用于注入游戏进程来捕获数据包，然后，我们另有一个程序，需要对捕获到的数据包进行处理，那么问题来了，另一个程序是怎么得到DLL捕获到的数据包呢？</p>
<p>相信你也知道答案了，当然是借助<strong>管道</strong>这个工具。</p>
<p>OK，那么什么是管道？</p>
<p>管道（Pipe）是<strong>操作系统</strong>中一种非常基础且重要的<strong>进程间通信</strong>机制。管道的本质是一个<strong>共享的、特殊的文件或内核缓冲区</strong>。它允许一个进程将数据写入这个缓冲区，而另一个进程从这个缓冲区读取数据。数据在管道中以<strong>字节流</strong>的形式单向流动。（AI如是说）</p>
<p>通常呢，管道分为<strong>匿名管道</strong>与<strong>命名管道</strong>。匿名管道一般是用作<strong>具备</strong>亲缘关系的进程之间使用的，而命名管道是用作<strong>没有</strong>亲缘关系的进程之间通信的。</p>
<p>管道有些类似数据和结构中的<strong>队列</strong>，它采用的是先进先出的顺序，并且它是单向的。</p>
<p>很显然，我们这里需要使用<strong>命名管道</strong>。</p>
<blockquote>
<p>具体实现就不说了，直接看源码。</p>
</blockquote>
<h4 id="数据捕获"><a href="#数据捕获" class="headerlink" title="数据捕获"></a>数据捕获</h4><p>经历了那么多，终于可以开始捕获数据了，这里就以捕获接收包为例子（为了方便理解，这里没有使用管道）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">S：当前接收数据的端点。</span></span><br><span class="line"><span class="comment">BufferPtr：指向缓冲区的指针，存放S接收的数据。</span></span><br><span class="line"><span class="comment">Length：缓冲区的大小。</span></span><br><span class="line"><span class="comment">Flag：接收标志位，控制接收方式。（本文没有用到）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">RecvEvent</span><span class="params">(SOCKET S, <span class="type">char</span> *BufferPtr, <span class="type">int</span> Length, <span class="type">int</span> Flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> Result = <span class="built_in">OriginalRecv</span>(S, BufferPtr, Length, Flag); <span class="comment">// 实际接收到的长度。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g_hookEnabled &amp;&amp; Result &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_DataMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">Temp</span><span class="params">(BufferPtr, BufferPtr + Result)</span></span>;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 处理本次接收到的数据。</span></span><br><span class="line">        PacketProcessor::<span class="built_in">ProcessRecvPacket</span>(S, Temp, Result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="开始处理数据包！"><a href="#开始处理数据包！" class="headerlink" title="开始处理数据包！"></a>开始处理数据包！</h3><p>现在接收到数据后，就需要想办法对数据进行处理了。</p>
<p>首先我创建了<code>PacketProcessor</code>类，用于处理这些数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PacketData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32_t</span> Length;  <span class="comment">// 包长 4字节</span></span><br><span class="line">    <span class="type">uint8_t</span> Version; <span class="comment">// 版本 1字节</span></span><br><span class="line">    <span class="type">int32_t</span> CmdID;   <span class="comment">// 命令号 4字节</span></span><br><span class="line">    <span class="type">int32_t</span> UserID;  <span class="comment">// 米米号 4字节</span></span><br><span class="line">    <span class="type">int32_t</span> SN;      <span class="comment">// 序列号 4字节</span></span><br><span class="line">    std::vector&lt;<span class="type">uint8_t</span>&gt; Body;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LogCout</span><span class="params">(<span class="type">bool</span> bIsSend)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PacketProcessor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ProcessRecvPacket</span><span class="params">(SOCKET Socket, <span class="type">const</span> vector&lt;<span class="type">char</span>&gt; &amp;Data, <span class="type">int</span> Length)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> PacketData <span class="title">ParsePacket</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">uint8_t</span>&gt; &amp;Packet)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">ShouldDecrypt</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">uint8_t</span>&gt; &amp;Cipher)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> vector&lt;<span class="type">uint8_t</span>&gt; <span class="title">DecryptPacket</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">uint8_t</span>&gt; &amp;Cipher)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Logining</span><span class="params">(PacketData &amp;InPacketData)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> vector&lt;<span class="type">uint8_t</span>&gt; s_RecvBuf;</span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> s_RecvBufIndex;</span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> s_RecvBufLen;</span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> s_RecvNum;</span><br><span class="line">    <span class="type">static</span> SOCKET s_CurrentSocket;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> s_HaveLogin;</span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> s_SN;</span><br><span class="line">    <span class="type">static</span> <span class="type">int32_t</span> s_UserID;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在介绍最关键的<code>ProcessRecvPacket</code>前呢，需要先了解一些基础知识：<strong>粘包</strong>和<strong>拆包</strong>、<strong>大端</strong>和<strong>小端</strong>。</p>
<h4 id="粘包和拆包"><a href="#粘包和拆包" class="headerlink" title="粘包和拆包"></a>粘包和拆包</h4><p>在使用TCP协议进行数据传输的过程中，TCP会将发送方的数据存储在缓冲区中，并根据网络状况优化数据包的大小进行传输，也就是说，TCP一次传递报文段可能由<strong>多个小的数据包组成</strong>，接收方接收时就可能出现多个数据包“粘”在一起的现象，这种情况就是粘包；同样的，如果单个数据包过大，超过了TCP 报文段的最大传输单元，那么TCP会将这个<strong>大的数据包拆分</strong>，并分为多个报文段进行传输，这样就造成了拆包。</p>
<h4 id="大端和小端"><a href="#大端和小端" class="headerlink" title="大端和小端"></a>大端和小端</h4><p>大小端是<strong>多字节数据的存储方式</strong>，它决定一个多字节类型在内存中按照什么顺序存放各个字节。</p>
<p>简单来说，对于作为<strong>正常人</strong>的我们来说，对于<code>123</code>这个数字，我们都会将其读作“一百二十三”，也就是大端，即高位在前，低位在后；但是，<strong>处理器</strong>不这么认为，它是怎么读的呢？</p>
<p>“三百二十一”</p>
<p>也就是说，它与正常人读取的方式完全相反，高位在后，低位在前。下方是比较专业的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">整数 0x12345678 的字节排列：</span><br><span class="line"></span><br><span class="line">地址:   0x00  0x01  0x02  0x03</span><br><span class="line">大端:   0x12  0x34  0x56  0x78</span><br><span class="line">小端:   0x78  0x56  0x34  0x12</span><br></pre></td></tr></table></figure>

<h4 id="ProcessRecvPacket"><a href="#ProcessRecvPacket" class="headerlink" title="ProcessRecvPacket"></a>ProcessRecvPacket</h4><p>先贴代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PacketProcessor::ProcessRecvPacket</span><span class="params">(SOCKET Socket, <span class="type">const</span> vector&lt;<span class="type">char</span>&gt; &amp;Data, <span class="type">int</span> Length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PacketData RecvPacketData = <span class="built_in">PacketData</span>();</span><br><span class="line"></span><br><span class="line">    s_RecvBuf.<span class="built_in">insert</span>(s_RecvBuf.<span class="built_in">end</span>(), Data.<span class="built_in">begin</span>(), Data.<span class="built_in">begin</span>() + Length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否是同一连接。</span></span><br><span class="line">    <span class="keyword">if</span> (s_CurrentSocket != Socket)</span><br><span class="line">    &#123;</span><br><span class="line">        s_RecvBufIndex += Length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时索引等于缓冲区长度，则说明刚好取完此包。</span></span><br><span class="line">        <span class="keyword">if</span> (s_RecvBufIndex == s_RecvBuf.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            s_RecvBuf.<span class="built_in">clear</span>();</span><br><span class="line">            s_RecvBufIndex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> Remain = s_RecvBuf.<span class="built_in">size</span>() - s_RecvBufIndex;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不足包头长度，需等待。</span></span><br><span class="line">        <span class="keyword">if</span> (Remain &lt; <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读包。</span></span><br><span class="line">        <span class="type">uint32_t</span> PacketLength = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;PacketLength, &amp;s_RecvBuf[s_RecvBufIndex], <span class="built_in">sizeof</span>(PacketLength));</span><br><span class="line">        PacketLength = <span class="built_in">ntohl</span>(PacketLength);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 包未齐，需等待。</span></span><br><span class="line">        <span class="keyword">if</span> (Remain &lt; PacketLength)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">uint8_t</span>&gt; <span class="title">Cipher</span><span class="params">(s_RecvBuf.begin() + s_RecvBufIndex, s_RecvBuf.begin() + s_RecvBufIndex + PacketLength)</span></span>;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">uint8_t</span>&gt; Plain = <span class="built_in">ShouldDecrypt</span>(Cipher) ? <span class="built_in">DecryptPacket</span>(Cipher) : Cipher;</span><br><span class="line"></span><br><span class="line">        RecvPacketData = <span class="built_in">ParsePacket</span>(Plain);</span><br><span class="line">        ++s_RecvNum;</span><br><span class="line">        RecvPacketData.<span class="built_in">LogCout</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是登录包</span></span><br><span class="line">        <span class="keyword">if</span> (RecvPacketData.CmdID == <span class="number">1001</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Logining</span>(RecvPacketData);</span><br><span class="line">            s_CurrentSocket = Socket;</span><br><span class="line">            s_SN = RecvPacketData.SN;</span><br><span class="line">            s_UserID = RecvPacketData.UserID;</span><br><span class="line">            s_HaveLogin = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s_RecvBufIndex += PacketLength;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s_RecvBufIndex == s_RecvBuf.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            s_RecvBuf.<span class="built_in">clear</span>();</span><br><span class="line">            s_RecvBufIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s_RecvBufIndex &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s_RecvBuf.<span class="built_in">erase</span>(s_RecvBuf.<span class="built_in">begin</span>(), s_RecvBuf.<span class="built_in">begin</span>() + s_RecvBufIndex);</span><br><span class="line">            s_RecvBufIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// s_CurrentSocket = Socket;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>私以为其中的重点为<strong>粘包</strong>、<strong>拆包</strong>以及<strong>登录包的处理</strong>的解决方法。</p>
<p>先说<strong>粘包</strong>和<strong>拆包</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> Remain = s_RecvBuf.<span class="built_in">size</span>() - s_RecvBufIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不足包头长度，需等待。</span></span><br><span class="line">    <span class="keyword">if</span> (Remain &lt; <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读包。</span></span><br><span class="line">    <span class="type">uint32_t</span> PacketLength = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;PacketLength, &amp;s_RecvBuf[s_RecvBufIndex], <span class="built_in">sizeof</span>(PacketLength));</span><br><span class="line">    PacketLength = <span class="built_in">ntohl</span>(PacketLength);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包未齐，需等待。</span></span><br><span class="line">    <span class="keyword">if</span> (Remain &lt; PacketLength)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">uint8_t</span>&gt; <span class="title">Cipher</span><span class="params">(s_RecvBuf.begin() + s_RecvBufIndex, s_RecvBuf.begin() + s_RecvBufIndex + PacketLength)</span></span>;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">uint8_t</span>&gt; Plain = <span class="built_in">ShouldDecrypt</span>(Cipher) ? <span class="built_in">DecryptPacket</span>(Cipher) : Cipher;</span><br><span class="line"></span><br><span class="line">    RecvPacketData = <span class="built_in">ParsePacket</span>(Plain);</span><br><span class="line">    ++s_RecvNum;</span><br><span class="line">    RecvPacketData.<span class="built_in">LogCout</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是登录包</span></span><br><span class="line">    <span class="keyword">if</span> (RecvPacketData.CmdID == <span class="number">1001</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Logining</span>(RecvPacketData);</span><br><span class="line">        s_CurrentSocket = Socket;</span><br><span class="line">        s_SN = RecvPacketData.SN;</span><br><span class="line">        s_UserID = RecvPacketData.UserID;</span><br><span class="line">        s_HaveLogin = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s_RecvBufIndex += PacketLength;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s_RecvBufIndex == s_RecvBuf.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        s_RecvBuf.<span class="built_in">clear</span>();</span><br><span class="line">        s_RecvBufIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s_RecvBufIndex &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s_RecvBuf.<span class="built_in">erase</span>(s_RecvBuf.<span class="built_in">begin</span>(), s_RecvBuf.<span class="built_in">begin</span>() + s_RecvBufIndex);</span><br><span class="line">        s_RecvBufIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// s_CurrentSocket = Socket;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我创建了多个全局变量用于处理上述问题：</p>
<ul>
<li><code>s_RecvBuf</code>：<strong>接收缓冲区</strong>，用于缓存接收来的数据流。</li>
<li><code>s_RecvBufIndex</code>：<strong>当前</strong>处理到的接收缓冲区<strong>索引</strong>。</li>
</ul>
<p>大致流程如下：</p>
<ol>
<li>判头长，先判断包头长度是否足够，不够则继续等待新的包。</li>
<li>读包头，将网络字节序（大端）转换为机器读法（小端）得到包长。</li>
<li>判包长，判断当前缓冲区的包是否完整，不完整继续等。</li>
<li>分析包，提取完整的数据包，进行解密分析。</li>
<li>清库存，更新缓冲区的状态，确保不会影响下一轮的分析。</li>
</ol>
<p>再说<strong>登陆包的处理：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (RecvPacketData.CmdID == <span class="number">1001</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Logining</span>(RecvPacketData);</span><br><span class="line">    s_CurrentSocket = Socket;</span><br><span class="line">    s_SN = RecvPacketData.SN;</span><br><span class="line">    s_UserID = RecvPacketData.UserID;</span><br><span class="line">    s_HaveLogin = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非常的清晰，如果命令号为<code>1001</code>，就代表此时为登录包，然后依照官方处理方法，对<code>key</code>进行处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PacketProcessor::Logining</span><span class="params">(PacketData &amp;InPacketData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (InPacketData.Body.<span class="built_in">size</span>() &lt; <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 取尾 4 字节并按“大端”组装</span></span><br><span class="line">    <span class="type">size_t</span> n = InPacketData.Body.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">uint32_t</span> tail4 = (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(InPacketData.Body[n - <span class="number">1</span>])) | (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(InPacketData.Body[n - <span class="number">2</span>]) &lt;&lt; <span class="number">8</span>) | (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(InPacketData.Body[n - <span class="number">3</span>]) &lt;&lt; <span class="number">16</span>) | (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(InPacketData.Body[n - <span class="number">4</span>]) &lt;&lt; <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 异或 userId</span></span><br><span class="line">    <span class="type">uint32_t</span> xorRes = tail4 ^ <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(InPacketData.UserID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 转为字符串</span></span><br><span class="line">    std::string plain = std::<span class="built_in">to_string</span>(xorRes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 计算 MD5</span></span><br><span class="line">    MD5 md5;</span><br><span class="line">    md<span class="number">5.</span><span class="built_in">update</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span> *&gt;(plain.<span class="built_in">data</span>()), plain.<span class="built_in">size</span>());</span><br><span class="line">    md<span class="number">5.f</span>inalize();</span><br><span class="line">    std::string md5hex = md<span class="number">5.</span><span class="built_in">hexdigest</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 取前 10 字符作密钥</span></span><br><span class="line">    std::string key = md5hex.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化加密算法</span></span><br><span class="line">    Cryptor::<span class="built_in">InitKey</span>(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们就得到的关键道具：<code>key</code>。在这之后呢，所有的数据包的解密都会用到<code>key</code>，现在我们可以随意地捕获并解密封包了。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>登录阶段，可以看到<code>LOGIN_IN</code>指令分别进行了一次发送与一次接收。</p>
<p><img src="https://blog-1314504743.cos.ap-nanjing.myqcloud.com/image-20250704232253744.jpg"></p>
<p>尝试移动一下，可以看到<code>PEOPLE_WALK</code>分别被发送和接收了一次，至于日志中为什么是两次，因为第一次没截好图。</p>
<p><img src="https://blog-1314504743.cos.ap-nanjing.myqcloud.com/image-20250704232406825.jpg"></p>
<p>那么到这里，封包解密基本结束了，下面进入第二阶段：</p>
<p><strong>“对战信息捕获与UI展示”</strong></p>
<p>这部分就自行研究吧！</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>本文仅用于<strong>技术研究与学习交流</strong>，请勿用于任何商业用途。</p>
<p>所有相关资源版权归<strong>上海淘米网络科技有限公司</strong>所有。</p>
<p>如因滥用本文造成法律纠纷，<strong>责任由使用者自行承担</strong>。</p>
<p>本文参考自<a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1468888-1-1.html">赛尔号：通信协议逆向与模拟&amp;中间人攻击窃取登录凭证</a></p>
<p><strong>联系方式</strong></p>
<p>邮箱：<a href="mailto:&#x35;&#x38;&#x34;&#x34;&#56;&#53;&#51;&#x32;&#x31;&#x40;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#109;">584485321@qq.com</a></p>
<hr>
<p>那么最后，赛尔号见！！！</p>
<hr>
</div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2025/02/13/Note/"><span class="level-item">随记</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-3-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/Hinami-Aoi.jpg" alt="Orca丶"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Orca丶</p><p class="is-size-6 is-block">爱开发游戏的菜鸟一枚</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives/"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories/"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags/"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/dauphinYan" target="_blank" rel="me noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/dauphinYan"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#前言"><span class="level-left"><span class="level-item">前言</span></span></a></li><li><a class="level is-mobile" href="#获取Flash文件并反编译"><span class="level-left"><span class="level-item">获取Flash文件并反编译</span></span></a></li><li><a class="level is-mobile" href="#尝试读源码！"><span class="level-left"><span class="level-item">尝试读源码！</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#通信数据解密"><span class="level-left"><span class="level-item">通信数据解密</span></span></a></li><li><a class="level is-mobile" href="#数据包格式解析"><span class="level-left"><span class="level-item">数据包格式解析</span></span></a></li><li><a class="level is-mobile" href="#找出修改Key的位置"><span class="level-left"><span class="level-item">找出修改Key的位置</span></span></a></li></ul></li><li><a class="level is-mobile" href="#制作我们自己的Hook"><span class="level-left"><span class="level-item">制作我们自己的Hook</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#本文中有什么作用？"><span class="level-left"><span class="level-item">本文中有什么作用？</span></span></a></li><li><a class="level is-mobile" href="#什么是Hook"><span class="level-left"><span class="level-item">什么是Hook?</span></span></a></li><li><a class="level is-mobile" href="#Hook选择"><span class="level-left"><span class="level-item">Hook选择</span></span></a></li><li><a class="level is-mobile" href="#Hook初始化"><span class="level-left"><span class="level-item">Hook初始化</span></span></a></li><li><a class="level is-mobile" href="#管道"><span class="level-left"><span class="level-item">管道</span></span></a></li><li><a class="level is-mobile" href="#数据捕获"><span class="level-left"><span class="level-item">数据捕获</span></span></a></li></ul></li><li><a class="level is-mobile" href="#开始处理数据包！"><span class="level-left"><span class="level-item">开始处理数据包！</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#粘包和拆包"><span class="level-left"><span class="level-item">粘包和拆包</span></span></a></li><li><a class="level is-mobile" href="#大端和小端"><span class="level-left"><span class="level-item">大端和小端</span></span></a></li><li><a class="level is-mobile" href="#ProcessRecvPacket"><span class="level-left"><span class="level-item">ProcessRecvPacket</span></span></a></li></ul></li><li><a class="level is-mobile" href="#测试"><span class="level-left"><span class="level-item">测试</span></span></a></li><li><a class="level is-mobile" href="#最后"><span class="level-left"><span class="level-item">最后</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E8%B5%9B%E5%B0%94%E5%8F%B7%E9%80%86%E5%90%91/"><span class="level-start"><span class="level-item">赛尔号逆向</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-07-03T07:47:54.000Z">2025-07-03</time></p><p class="title"><a href="/2025/07/03/game-reversing/network-protocol-reversing/">赛尔号逆向：封包分析</a></p><p class="categories"><a href="/categories/%E8%B5%9B%E5%B0%94%E5%8F%B7%E9%80%86%E5%90%91/">赛尔号逆向</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-13T09:56:21.000Z">2025-02-13</time></p><p class="title"><a href="/2025/02/13/Note/">随记</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/favicon.ico" alt="Orca丶的博客" height="28"></a><p class="is-size-7"><span>&copy; 2025 Orca丶</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>