{"posts":[{"title":"随记","text":"2025-2-13力扣题海无涯，刷到手软心力尽； 算法难关如山高，解时头昏眼花重。 2025-4-3行路难，行路难，多歧路，今安在？ 春招游戏客户端对于双非还是太难了！","link":"/2025/02/13/Note/"},{"title":"赛尔号逆向：封包分析","text":"文章内容完善中…… 前言作者是一名赛尔号PVP玩家，最近胜率一直不高，因此决定制作一款巅峰辅助工具。 本人此前从未接触过网络通信这一块，基本是现学现用，因此可能会存在部分问题，还望大佬们指出！ 本文所用工具如下： 工具 描述 Fiddler Classic 抓包工具 JPEXS Free Flash Decompiler Flash文件反编译工具 x64dbg 程序调试器 项目开源地址：https://github.com/dauphinYan/SeerAssistant 获取Flash文件并反编译本阶段用到的工具：Fiddler Classic、JPEXS Free Flash Decompiler。 这部分暂时跳过…（可以参考文末链接） 反编译成功后，我们会得到下述四个文件夹： 1234ClientRobotAppDLLRobotCoreDLLTaomeeLibrary 尝试读源码！通信数据解密我们可以在前面反编译得到的TaomeeLibrary文件夹中搜索socket，毕竟网络通信都需要使用到socket，所以可以使用这种方法快速接近目标。然后，我们发现了十分显眼的MDecrypt.as，赶快进去瞧瞧！ 可以看到MDecrypt.as的主要函数为： 1public function MDecrypt(param1:ByteArray, param2:int, param3:ByteArray) : void 因此我们需要弄清传入的三个参数对应的含义。 同样，在TameeLibrary文件夹中搜索MDecrypt(，这里有一个技巧，在末尾添加(就可以快速找到该函数在哪里实现以及调用。 现在可以清楚的看到在MessageEncrypt.as中有调用，我们进去看看。 12345678910111213private static var NO_ENCRYPT_LEN:int = 4; public static function decrypt(inData:ByteArray) : ByteArray { var inLen:int = inData.readUnsignedInt() - NO_ENCRYPT_LEN; var outData:ByteArray = new ByteArray(); outData.writeUnsignedInt(0); MDecrypt(inData,inLen,outData); outData.position = 0; outData.writeUnsignedInt(outData.length); outData.position = 0; return outData; } 通过这个函数实现，可以大胆猜测： InData：传入的数据包。 inLen：真正需要解密的部分。 outData：解密后的数据包。 NO_ENCRYPT_LEN：记录数据包的长度信息。（这里大胆猜测，前四字节为包体长度） 为什么这么猜测呢？因为数据在传递的过程中，数据不是逐字节的发送的，而是以数据包的形式成批发送，那么发送方为了让接收方区分接收到的数据，通常会在数据包头部保留明文片段用于标识数据包的长度。 MDecrypt.as源码可读性比较差，有兴趣可以自行阅读分析，使用C++重写的源码可见下方。 C++重写后的解密源码： 123456789101112131415161718192021222324252627282930313233343536373839404142std::vector&lt;uint8_t&gt; Cryptor::Decrypt(const std::vector&lt;uint8_t&gt; &amp;Cipher){ size_t len = Cipher.size(); if (len == 0 || Key.empty()) return {}; // 计算旋转量 int result = Key[(len - 1) % Key.size()] * 13 % len; // 环形右移 result 个字节 std::vector&lt;uint8_t&gt; rotated = Merge( Slice(Cipher, len - result, len), Slice(Cipher, 0, len - result)); // 右移/左移组合恢复原始字节序列（去掉最后一个字节） std::vector&lt;uint8_t&gt; plain(len - 1); for (size_t i = 0; i &lt; len - 1; ++i) { plain[i] = static_cast&lt;uint8_t&gt;((rotated[i] &gt;&gt; 5) | (rotated[i + 1] &lt;&lt; 3)); } // 异或解密 size_t j = 0; bool NeedBecomeZero = false; for (size_t i = 0; i &lt; plain.size(); ++i) { if (j == 1 &amp;&amp; NeedBecomeZero) { j = 0; NeedBecomeZero = false; } if (j == Key.size()) { j = 0; NeedBecomeZero = true; } plain[i] = static_cast&lt;uint8_t&gt;(plain[i] ^ Key[j]); ++j; } return plain;} 不过有一点需要注意，在官方的源码中 1_loc11_ = CModule.mallocString(getDefinitionByName(&quot;com.robot.core.net.SocketConnection&quot;).key); _loc11_在很多处都有参与运算，因此我们需要弄清楚这个值是怎么来的。 根据路径找到SocketConnection.as，发现关键函数key()： 1234567891011121314151617181920212223private static var _encryptKeyStringArr:Array;public static function get key() : String{ var _loc2_:int = 0; var _loc3_:String = null; var _loc1_:String = &quot;&quot;; if(_encryptKeyStringArr == null) { _loc1_ = &quot;!crAckmE4nOthIng:-)&quot;; } else { _loc2_ = 0; while(_loc2_ &lt; _encryptKeyStringArr.length) { _loc3_ = StringUtil.replace(_encryptKeyStringArr[_loc2_],&quot;*&quot;,&quot;&quot;); _loc1_ += _loc3_; _loc2_++; } } return _loc1_;} 不难知道，默认情况下key的值为!crAckmE4nOthIng:-)，这个密钥看着很像某些单词的缩写，简单解读一下。 crAckmE：Crack me. 4：for. nOthIng：Nothing. 连起来也就是： 1Crack me for nothing. 试着破解我吧，反正也没啥有用的东西😊 这里感谢”圆圆圆“提供的解释。 显然，这个key在后面肯定会被修改，我们在这个文件中又找到的修改函数： 1234public static function setEncryptKeyStringArr(param1:Array) : void{ _encryptKeyStringArr = param1;} 因此在文件夹中搜索setEncryptKeyStringArr(，得到结果如下图所示： 只找到一处该方法的调用，和我们的预期有所差距： 123456789101112131415161718192021222324252627282930private static function onSocketClose(param1:Event) : void{ var event:Event = param1; DebugTrace.show(&quot;////////////////////////////////////////////////////////////////////////////////\\r//\\r//\\t\\t\\t\\t&quot; + &quot;socket was closed\\r//\\r////////////////////////////////////////////////////////////////////////////////&quot;); try { SocketConnection.mainSocket.removeEventListener(Event.CLOSE,onSocketClose); SocketConnection.setEncryptKeyStringArr(null); SocketConnectionHelper.clear(); ModuleManager.hideAllModule(); if(login10004) { return; } Alarm.show(&quot;此次连接已经断开，请重新登录&quot;,function():void { if(ExternalInterface.available) { navigateToURL(new URLRequest(&quot;javascript:window.location.reload();&quot;),&quot;_self&quot;); } else { navigateToURL(new URLRequest(&quot;https://seer.61.com&quot;),&quot;_self&quot;); } },false,true,false,LevelManager.stage); } catch(e:Error) { }} 可以看到这部分发生在与游戏服务器断开的阶段，并没有达到修改key的目的，现在就比较麻烦了。 既然如此，那我们先去开一把休息一下，羁绊后的伽马强度还是太爆炸了…… 数据包格式解析在找key之前呢，可以先看看官方是如何解析数据包的，前面我们知道MessageEncrypt.as有一个decrypt(函数，很明显，这是一个套壳函数，没有解析数据的具体实现。因此文件夹中搜索decrypt(，可以定位到SocketEncryptImpl.as，其中包含一个函数： 12345678910111213141516171819202122232425262728293031323334353637private function onData(e:Event) : void{ var msgLen:int = 0; var ba:ByteArray = null; DebugTrace.show(&quot;socket onData handler....................&quot;); this._chunkBuffer.clear(); if(this._tempBuffer.length &gt; 0) { this._tempBuffer.position = 0; this._tempBuffer.readBytes(this._chunkBuffer,0,this._tempBuffer.length); this._tempBuffer.clear(); } readBytes(this._chunkBuffer,this._chunkBuffer.length,bytesAvailable); this._chunkBuffer.position = 0; while(this._chunkBuffer.bytesAvailable &gt; 0) { if(this._chunkBuffer.bytesAvailable &gt; MSG_FIRST_TOKEN_LEN) { msgLen = this._chunkBuffer.readUnsignedInt() - MSG_FIRST_TOKEN_LEN; if(this._chunkBuffer.bytesAvailable &gt;= msgLen) { this._chunkBuffer.position -= MSG_FIRST_TOKEN_LEN; ba = MessageEncrypt.decrypt(this._chunkBuffer); // 在这里！ this.parseData(ba); } else { this._chunkBuffer.position -= MSG_FIRST_TOKEN_LEN; this._chunkBuffer.readBytes(this._tempBuffer,0,this._chunkBuffer.bytesAvailable); } } else { this._chunkBuffer.readBytes(this._tempBuffer,0,this._chunkBuffer.bytesAvailable); } }} 在解密函数的下方，有一个ParseData函数，翻译过来就是”解析数据“。那么我们定位到那里去： 123456789101112131415161718192021222324252627282930313233343536373839404142private static const HEAD_LENGTH:uint = 17;private function parseData(data:ByteArray) : void { var info:ByteArray = null; var tmfClass:Class = null; this._packageLen = data.readUnsignedInt(); if(this._packageLen &lt; HEAD_LENGTH || this._packageLen &gt; PACKAGE_MAX) { this.readDataError(0); dispatchEvent(new SocketErrorEvent(SocketErrorEvent.ERROR,null)); data.readBytes(new ByteArray()); return; } this._headInfo = new HeadInfo(data); if(this._headInfo.cmdID == 1001) { this._result = this._headInfo.result; } DebugTrace.show(&quot;&lt;&lt;Socket[&quot; + this.ip + &quot;:&quot; + this.port.toString() + &quot;][cmdID:&quot; + this._headInfo.cmdID + &quot;]&quot;,getCmdLabel(this._headInfo.cmdID)); if(this._headInfo.result &gt; 1000) { this.readDataError(this._headInfo.cmdID); this.dispatchError(this._headInfo.cmdID,this._headInfo); dispatchEvent(new SocketErrorEvent(SocketErrorEvent.ERROR,this._headInfo)); return; } this._dataLen = this._packageLen - HEAD_LENGTH; if(this._dataLen == 0) { this.readDataError(this._headInfo.cmdID); this.dispatchCmd(this._headInfo.cmdID,this._headInfo,null); } else { info = new ByteArray(); data.readBytes(info,0,this._dataLen); tmfClass = TMF.getClass(this._headInfo.cmdID); this.readDataError(this._headInfo.cmdID); this.dispatchCmd(this._headInfo.cmdID,this._headInfo,new tmfClass(info)); } } 可以看到，Debug输出与_headInfo有关，那么同样的方式，我们定位到HeadInfo 12345678public function HeadInfo(headData:IDataInput){ super(); this._version = headData.readUTFBytes(1); // 版本号，1字节 this._cmdID = headData.readUnsignedInt(); // 命令号，4字节 this._userID = headData.readUnsignedInt(); // 用户号，4字节 this._result = headData.readInt(); // 序列号，4字节} 再次阅读代码，现在封包的结构就十分明确了： 1234567// 封包长度, 4字节|版本号，1字节|命令号，4字节|用户号，4字节|序列号，4字节|包体数据this._packageLen = data.readUnsignedInt(); // 封包长度, 4字节this._headInfo = new HeadInfo(data); // 头部信息，13字节this._dataLen = this._packageLen - HEAD_LENGTH; // 包体长度 这里补充一下，我们会发现在parseData()函数中，有一处命令ID的判断： 1234if(this._headInfo.cmdID == 1001){ this._result = this._headInfo.result;} 可以尝试在文件夹中搜索cmdID，接着我们会发现： 这里有一个cmdID的值为41129，接着我们继续搜索41129，然后我们会找到CommandID.as文件夹，这里面就包含了所有命令的ID，下面截取部分内容： 1234567891011121314151617181920package com.robot.core{ public class CommandID { public static const LOADING_TIME_STAT:uint = 9303; public static const GET_PET_TOWER_ACHIEVE:uint = 3453; public static const RECEIVE_PRANKSTER_REWARD:uint = 1014; public static const TOPFIGHT_RANKING_LIST:uint = 2459; public static const TOPFIGHT_GET_AWARD:uint = 9374; public static const TOPFIGHT_WEEK_WIN:uint = 2532; public static const TOPFIGHT_BEYOND:uint = 2567; }} 找到这个文件的方法有很多，这里只列举其中一种，最开始找到这个文件的方法我忘记了，上述方法是临时找的。 找出修改Key的位置回到这里，既然找不到修改key的位置，我们不妨先使用当前已经得到的解密算法对接收到的数据进行解密，这里选用Hook注入的方法（现在不清楚不用着急，后面会介绍的），解密得到的信息如下： 1234567891011121314151617181920[2025-07-03 15:22:54.849] [ThreadID 0xfb8] [Temp] [Hooked send] Parsed Data:[Length=17 Version=49 CmdID=111 Cmd=———— UserID=123456789 SN=0 BodySize=0] [2025-07-03 15:22:54.874] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=21 Version=0 CmdID=111 Cmd=———— UserID=123456789 SN=0 BodySize=4] Body=[00 00 00 00 ][2025-07-03 15:22:54.878] [ThreadID 0xfb8] [Temp] [Hooked send] Parsed Data:[Length=37 Version=49 CmdID=109 Cmd=SYS_ROLE UserID=123456789 SN=0 BodySize=20] Body=[a4 0e a7 cc 84 21 87 f2 f6 91 51 9a 7a 0e b7 6e ...][2025-07-03 15:22:54.903] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=21 Version=0 CmdID=109 Cmd=SYS_ROLE UserID=123456789 SN=0 BodySize=4] Body=[00 00 00 00 ][2025-07-03 15:22:54.905] [ThreadID 0xfb8] [Temp] [Hooked send] Parsed Data:[Length=37 Version=49 CmdID=105 Cmd=COMMEND_ONLINE UserID=123456789 SN=0 BodySize=20] Body=[a4 0e a7 cc 84 21 87 f2 f6 91 51 9a 7a 0e b7 6e ...][2025-07-03 15:22:54.934] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=561 Version=0 CmdID=105 Cmd=COMMEND_ONLINE UserID=123456789 SN=0 BodySize=544] Body=[00 00 0b 99 00 00 00 03 00 79 ec 33 00 00 00 02 ...][2025-07-03 15:23:06.439] [ThreadID 0xfb8] [Temp] [Hooked send] Parsed Data:[Length=141 Version=49 CmdID=1001 Cmd=LOGIN_IN UserID=123456789 SN=202 BodySize=124] Body=[a4 0e a7 cc 84 21 87 f2 f6 91 51 9a 7a 0e b7 6e ...][2025-07-03 15:23:06.989] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=171 Version=62 CmdID=8002 Cmd=SYSTEM_MESSAGE UserID=123456789 SN=0 BodySize=154] Body=[00 01 88 43 68 66 2f da 00 00 00 8e 20 e7 b2 be ...][2025-07-03 15:23:06.995] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=171 Version=62 CmdID=8002 Cmd=SYSTEM_MESSAGE UserID=123456789 SN=0 BodySize=154] Body=[00 01 88 43 68 66 2f da 00 00 00 8e 20 e7 b2 be ...][2025-07-03 15:23:06.996] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=113 Version=62 CmdID=8002 Cmd=SYSTEM_MESSAGE UserID=123456789 SN=0 BodySize=96] Body=[00 01 88 43 68 66 2f da 00 00 00 54 e5 a6 82 e6 ...][2025-07-03 15:23:06.996] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=129 Version=62 CmdID=8002 Cmd=SYSTEM_MESSAGE UserID=123456789 SN=0 BodySize=112] Body=[00 00 00 03 68 66 2f da 00 00 00 64 20 e4 bd a0 ...][2025-07-03 15:23:06.997] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=25 Version=62 CmdID=3452 Cmd=LASTVALUE UserID=123456789 SN=0 BodySize=8] Body=[00 00 00 7f 00 00 00 32 ][2025-07-03 15:23:06.997] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=25 Version=62 CmdID=3452 Cmd=LASTVALUE UserID=123456789 SN=0 BodySize=8] Body=[00 00 00 63 00 00 00 02 ][2025-07-03 15:23:06.997] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=25 Version=62 CmdID=2394 Cmd=PET_BOOK_UPDATE UserID=123456789 SN=0 BodySize=8] Body=[00 00 05 1c 00 00 00 01 ][2025-07-03 15:23:06.998] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=25 Version=62 CmdID=3452 Cmd=LASTVALUE UserID=123456789 SN=0 BodySize=8] Body=[00 00 00 2b 00 00 00 3c ][2025-07-03 15:23:06.998] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=25 Version=62 CmdID=3452 Cmd=LASTVALUE UserID=123456789 SN=0 BodySize=8] Body=[00 00 00 2b 00 00 00 00 ][2025-07-03 15:23:06.998] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=25 Version=62 CmdID=3452 Cmd=LASTVALUE UserID=123456789 SN=0 BodySize=8] Body=[00 00 00 2b 00 00 01 54 ][2025-07-03 15:23:06.998] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=25 Version=62 CmdID=3452 Cmd=LASTVALUE UserID=123456789 SN=0 BodySize=8] Body=[00 00 00 2b 00 00 08 8b ][2025-07-03 15:23:06.999] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=25 Version=62 CmdID=3452 Cmd=LASTVALUE UserID=123456789 SN=0 BodySize=8] Body=[00 00 00 2b 00 00 0a 31 ][2025-07-03 15:23:07.031] [ThreadID 0xfb8] [Temp] [Hooked recv] Parsed Data:[Length=3413 Version=62 CmdID=1001 Cmd=LOGIN_IN UserID=123456789 SN=46 BodySize=3396] Body=[0d b2 32 92 4d 71 dc 79 e7 89 9b e6 8e 92 00 00 ...] 这里只截取正常的部分（UserID我就用”123456”代替了），从接收到LOGIN_IN指令以后，数据变得非常奇怪，也就是说，key值的改变发生在接收到LOGIN_IN指令后！ 在文件夹中搜索LOGIN_IN，结果不多，挨个查看下，最后锁定在MainEntry.as： 12345678910111213141516171819202122232425262728293031323334353637383940414243private static function onLogin(param1:SocketEvent) : void{ if(SaveUserInfo.loginIDInfo.loginType == 3) { StatManager.sendStat2014(&quot;手机验证码注册/登录&quot;,&quot;【手机验证码登录玩家】登录ONLINE服&quot;,&quot;手机验证码&quot;); } if(MainManager.isNewUser) { StatManager.sendStat2014(&quot;_newtrans_&quot;,&quot;fOnlineSucc&quot;,&quot;&quot;); } if(!isReconnect) { SocketConnection.removeCmdListener(CommandID.LOGIN_IN,onLogin); EventManager.addEventListener(RobotEvent.CREATED_ACTOR,onCreatedActor); } else { SocketConnection.removeCmdListener(CommandID.RELOGIN_IN,onLogin); } var _loc2_:int = 0; if(isReconnect) { _loc2_ = int(MainManager.actorInfo.mapID); } MainManager.setup(param1.data,isReconnect,_loc2_); var _loc3_:ByteArray = param1.data as ByteArray; var _loc4_:int = int(_loc3_.readUnsignedInt()); initKey(_loc4_); MainEntry.login10004 = false; LevelManager.openMouseEvent(); if(isReconnect) { MainManager.reconnectRequest(); EventManager.dispatchEvent(new Event(ReconnectCompleteController.RECONNECTSUC)); } if(!isReconnect) { MapConfig.setup(); MapSeatPointConfig.setup(); } sendSystemInfo(); SocketConnection.send(1022,86066824);} 然后我们会发现一个特别显眼的函数：initKey(_loc4_) 123456789101112131415161718192021private static function initKey(param1:int) : void{ var _loc2_:String = &quot;c&amp;o&amp;m.--rob-ot.c--o-r-e.&amp;n-et.S-oc-ke-t&amp;C-on-n-e-c-t-i-on&quot;; var _loc3_:* = &quot;s*e*tE&amp;&amp;&amp;n*c&quot;; _loc3_ += &quot;r*yp*t&amp;&amp;&amp;&amp;Ke*yS*tr*i&amp;n&amp;&amp;g*Arr&quot;; _loc2_ = StringUtil.replace(_loc2_,&quot;-&quot;,&quot;&quot;); _loc2_ = StringUtil.replace(_loc2_,&quot;&amp;&quot;,&quot;&quot;); _loc3_ = StringUtil.replace(_loc3_,&quot;*&quot;,&quot;&quot;); _loc3_ = StringUtil.replace(_loc3_,&quot;&amp;&quot;,&quot;&quot;); param1 ^= MainManager.actorInfo.userID; var _loc4_:String = MD5.hash(param1 + &quot;&quot;); var _loc5_:* = MainManager.actorInfo.userID + &quot;&quot;; var _loc6_:Array = []; var _loc7_:int = 0; while(_loc7_ &lt; 10) { _loc6_[_loc7_] = &quot;*&quot; + _loc4_.charAt(_loc7_) + &quot;*&quot;; _loc7_++; } getDefinitionByName(_loc2_)[_loc3_](_loc6_);} 处理一下，就可以的得到： 12_loc2_ = &quot;com.robot.core.net.SocketConnection&quot;;_loc3_ = &quot;setEncryptKeyStringArr&quot;; 这种避免直接通过字符串搜索的方法学到了！ 发现没，_loc3_就是我们前面只能找到一处调用的方法setEncryptKeyStringArr。 制作我们自己的Hook本文中有什么作用？在本文中，我们的最终目的是对网络通信中的数据包进行解密，因此如何捕获数据非常重要。为了实现这一目的，就需要请出本节主角：Hook！ 什么是Hook?Hook，又称钩子，是一种能够拦截和修改函数或方法的技术。它允许开发者在不修改原有的代码前提下，修改程序的行为。 例如在网络通信中，我们通过我们通过Hook拦截网络API的调用，例如send、recv等，这样就可以捕获网络通信中的一段十六进制数据： 13c 3f 78 6d 6c 20 76 65 72 73 69 6f 6e 3d 22 31 2e 30 22 3f 3e 3c 21 44 4f 43 54 59 50 45 20 63 72 6f 73 73 2d 64 6f 6d 61 69 6e 2d 70 6f 6c 69 63 79 3e 3c 63 72 6f 73 73 2d 64 6f 6d 61 69 6e 2d 70 6f 6c 69 63 79 3e 3c 61 6c 6c 6f 77 2d 61 63 63 65 73 73 2d 66 72 6f 6d 20 64 6f 6d 61 69 6e 3d 22 2a 22 20 74 6f 2d 70 6f 72 74 73 3d 22 2a 22 20 2f 3e 3c 2f 63 72 6f 73 73 2d 64 6f 6d 61 69 6e 2d 70 6f 6c 69 63 79 3e 00 将其转换为ASCII字符就可以得到： 12345&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE cross-domain-policy&gt;&lt;cross-domain-policy&gt; &lt;allow-access-from domain=&quot;*&quot; to-ports=&quot;*&quot; /&gt;&lt;/cross-domain-policy&gt; 当然了，这个肯定是我们不需要的数据。 总的来说，Hook在本文的作用就是捕获我们需要分析的数据包。 Hook选择一般情况下，Hook都是以DLL的形式注入到进程中，然后对进程进行修改，所以我们也需要制作DLL文件。 考虑到使用Windows原生API实现Hook难度不小，因此本文采用第三方开源库MinHook。 链接：https://github.com/TsudaKageyu/minhook MinHook的实现就非常方便了，大致流程如下： 1234567891011121314// 初始化MH_STATUS WINAPI MH_Initialize(VOID);// 创建钩子 pTarget：需要替换的目标函数地址。 pDetour：我们自己创建的函数地址。 ppOriginal：用于保存原始函数指针（方便绕过Hook）MH_STATUS WINAPI MH_CreateHook(LPVOID pTarget, LPVOID pDetour, LPVOID *ppOriginal);// 启动钩子MH_STATUS WINAPI MH_EnableHook(LPVOID pTarget)// 关闭钩子MH_STATUS WINAPI MH_DisableHook(LPVOID pTarget) // 收工后的一些处理MH_STATUS WINAPI MH_Uninitialize(VOID); Hook初始化在初始化前呢，我们应当明确需要拦截的地方，这里就不得不提到ws2_32.dll这个文件了。 ws2_32.dll是Windows Sockets API的实现，通常网络通信都会用到它，以Flash端为例，数据传输的过程中通常会调用send和recv方法，因此我们只需要拦截这两个方法即可。 根据MinHook提供的初始化办法，我们需要获取： pTarget：需要替换的目标函数地址。 pDetour：我们自己创建的函数地址。 ppOriginal：用于保存原始函数指针（方便绕过Hook）。 1234567891011// 首先加载ws2_32.dllHMODULE ws2_32 = nullptr;ws2_32 = GetModuleHandleW(L&quot;ws2_32&quot;);// 获取函数地址LPVOID targetSend = reinterpret_cast&lt;LPVOID&gt;(GetProcAddress(ws2_32, &quot;send&quot;));LPVOID targetRecv = reinterpret_cast&lt;LPVOID&gt;(GetProcAddress(ws2_32, &quot;recv&quot;));// 定义原始函数指针decltype(&amp;recv) originalRecv = nullptr;decltype(&amp;send) originalSend = nullptr; 管道别着急，捕获数据前还需要了解一个知识点：管道。 先明确我们的需求： 假设，我们创建了一个DLL用于注入游戏进程来捕获数据包，然后，我们另有一个程序，需要对捕获到的数据包进行处理，那么问题来了，另一个程序是怎么得到DLL捕获到的数据包呢？ 相信你也知道答案了，当然是借助管道这个工具。 OK，那么什么是管道？ 管道（Pipe）是操作系统中一种非常基础且重要的进程间通信机制。管道的本质是一个共享的、特殊的文件或内核缓冲区。它允许一个进程将数据写入这个缓冲区，而另一个进程从这个缓冲区读取数据。数据在管道中以字节流的形式单向流动。（AI如是说） 通常呢，管道分为匿名管道与命名管道。匿名管道一般是用作具备亲缘关系的进程之间使用的，而命名管道是用作没有亲缘关系的进程之间通信的。 管道有些类似数据和结构中的队列，它采用的是先进先出的顺序，并且它是单向的。 很显然，我们这里需要使用命名管道。 具体实现就不说了，直接看源码。 数据捕获经历了那么多，终于可以开始捕获数据了，这里就以捕获接收包为例子（为了方便理解，这里没有使用管道）： 12345678910111213141516171819202122/* S：当前接收数据的端点。BufferPtr：指向缓冲区的指针，存放S接收的数据。Length：缓冲区的大小。Flag：接收标志位，控制接收方式。（本文没有用到）*/int WINAPI RecvEvent(SOCKET S, char *BufferPtr, int Length, int Flag){ int Result = OriginalRecv(S, BufferPtr, Length, Flag); // 实际接收到的长度。 if (g_hookEnabled &amp;&amp; Result &gt; 0) { std::lock_guard&lt;std::mutex&gt; lock(g_DataMutex); std::vector&lt;char&gt; Temp(BufferPtr, BufferPtr + Result); // 处理本次接收到的数据。 PacketProcessor::ProcessRecvPacket(S, Temp, Result); } return Result;} 开始处理数据包！现在接收到数据后，就需要想办法对数据进行处理了。 首先我创建了PacketProcessor类，用于处理这些数据。 12345678910111213141516171819202122232425262728293031323334struct PacketData{ int32_t Length; // 包长 4字节 uint8_t Version; // 版本 1字节 int32_t CmdID; // 命令号 4字节 int32_t UserID; // 米米号 4字节 int32_t SN; // 序列号 4字节 std::vector&lt;uint8_t&gt; Body; void LogCout(bool bIsSend) const;};class PacketProcessor{public: static void ProcessRecvPacket(SOCKET Socket, const vector&lt;char&gt; &amp;Data, int Length); static PacketData ParsePacket(const vector&lt;uint8_t&gt; &amp;Packet); static bool ShouldDecrypt(const vector&lt;uint8_t&gt; &amp;Cipher); static vector&lt;uint8_t&gt; DecryptPacket(const vector&lt;uint8_t&gt; &amp;Cipher); static void Logining(PacketData &amp;InPacketData);private: static vector&lt;uint8_t&gt; s_RecvBuf; static size_t s_RecvBufIndex; static size_t s_RecvBufLen; static size_t s_RecvNum; static SOCKET s_CurrentSocket; static bool s_HaveLogin; static size_t s_SN; static int32_t s_UserID;}; 在介绍最关键的ProcessRecvPacket前呢，需要先了解一些基础知识：粘包和拆包、大端和小端。 粘包和拆包在使用TCP协议进行数据传输的过程中，TCP会将发送方的数据存储在缓冲区中，并根据网络状况优化数据包的大小进行传输，也就是说，TCP一次传递报文段可能由多个小的数据包组成，接收方接收时就可能出现多个数据包“粘”在一起的现象，这种情况就是粘包；同样的，如果单个数据包过大，超过了TCP 报文段的最大传输单元，那么TCP会将这个大的数据包拆分，并分为多个报文段进行传输，这样就造成了拆包。 大端和小端大小端是多字节数据的存储方式，它决定一个多字节类型在内存中按照什么顺序存放各个字节。 简单来说，对于作为正常人的我们来说，对于123这个数字，我们都会将其读作“一百二十三”，也就是大端，即高位在前，低位在后；但是，处理器不这么认为，它是怎么读的呢？ “三百二十一” 也就是说，它与正常人读取的方式完全相反，高位在后，低位在前。下方是比较专业的例子： 12345整数 0x12345678 的字节排列：地址: 0x00 0x01 0x02 0x03大端: 0x12 0x34 0x56 0x78小端: 0x78 0x56 0x34 0x12 ProcessRecvPacket先贴代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273void PacketProcessor::ProcessRecvPacket(SOCKET Socket, const vector&lt;char&gt; &amp;Data, int Length){ PacketData RecvPacketData = PacketData(); s_RecvBuf.insert(s_RecvBuf.end(), Data.begin(), Data.begin() + Length); // 是否是同一连接。 if (s_CurrentSocket != Socket) { s_RecvBufIndex += Length; // 此时索引等于缓冲区长度，则说明刚好取完此包。 if (s_RecvBufIndex == s_RecvBuf.size()) { s_RecvBuf.clear(); s_RecvBufIndex = 0; } return; } while (true) { size_t Remain = s_RecvBuf.size() - s_RecvBufIndex; // 不足包头长度，需等待。 if (Remain &lt; sizeof(uint32_t)) break; // 读包。 uint32_t PacketLength = 0; memcpy(&amp;PacketLength, &amp;s_RecvBuf[s_RecvBufIndex], sizeof(PacketLength)); PacketLength = ntohl(PacketLength); // 包未齐，需等待。 if (Remain &lt; PacketLength) break; vector&lt;uint8_t&gt; Cipher(s_RecvBuf.begin() + s_RecvBufIndex, s_RecvBuf.begin() + s_RecvBufIndex + PacketLength); vector&lt;uint8_t&gt; Plain = ShouldDecrypt(Cipher) ? DecryptPacket(Cipher) : Cipher; RecvPacketData = ParsePacket(Plain); ++s_RecvNum; RecvPacketData.LogCout(false); // 如果是登录包 if (RecvPacketData.CmdID == 1001) { Logining(RecvPacketData); s_CurrentSocket = Socket; s_SN = RecvPacketData.SN; s_UserID = RecvPacketData.UserID; s_HaveLogin = true; } s_RecvBufIndex += PacketLength; if (s_RecvBufIndex == s_RecvBuf.size()) { s_RecvBuf.clear(); s_RecvBufIndex = 0; break; } if (s_RecvBufIndex &gt; 0) { s_RecvBuf.erase(s_RecvBuf.begin(), s_RecvBuf.begin() + s_RecvBufIndex); s_RecvBufIndex = 0; // s_CurrentSocket = Socket; } }} 私以为其中的重点为粘包、拆包以及登录包的处理的解决方法。 先说粘包和拆包： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950while (true){ size_t Remain = s_RecvBuf.size() - s_RecvBufIndex; // 不足包头长度，需等待。 if (Remain &lt; sizeof(uint32_t)) break; // 读包。 uint32_t PacketLength = 0; memcpy(&amp;PacketLength, &amp;s_RecvBuf[s_RecvBufIndex], sizeof(PacketLength)); PacketLength = ntohl(PacketLength); // 包未齐，需等待。 if (Remain &lt; PacketLength) break; vector&lt;uint8_t&gt; Cipher(s_RecvBuf.begin() + s_RecvBufIndex, s_RecvBuf.begin() + s_RecvBufIndex + PacketLength); vector&lt;uint8_t&gt; Plain = ShouldDecrypt(Cipher) ? DecryptPacket(Cipher) : Cipher; RecvPacketData = ParsePacket(Plain); ++s_RecvNum; RecvPacketData.LogCout(false); // 如果是登录包 if (RecvPacketData.CmdID == 1001) { Logining(RecvPacketData); s_CurrentSocket = Socket; s_SN = RecvPacketData.SN; s_UserID = RecvPacketData.UserID; s_HaveLogin = true; } s_RecvBufIndex += PacketLength; if (s_RecvBufIndex == s_RecvBuf.size()) { s_RecvBuf.clear(); s_RecvBufIndex = 0; break; } if (s_RecvBufIndex &gt; 0) { s_RecvBuf.erase(s_RecvBuf.begin(), s_RecvBuf.begin() + s_RecvBufIndex); s_RecvBufIndex = 0; // s_CurrentSocket = Socket; } 我创建了多个全局变量用于处理上述问题： s_RecvBuf：接收缓冲区，用于缓存接收来的数据流。 s_RecvBufIndex：当前处理到的接收缓冲区索引。 大致流程如下： 判头长，先判断包头长度是否足够，不够则继续等待新的包。 读包头，将网络字节序（大端）转换为机器读法（小端）得到包长。 判包长，判断当前缓冲区的包是否完整，不完整继续等。 分析包，提取完整的数据包，进行解密分析。 清库存，更新缓冲区的状态，确保不会影响下一轮的分析。 再说登陆包的处理： 12345678if (RecvPacketData.CmdID == 1001){ Logining(RecvPacketData); s_CurrentSocket = Socket; s_SN = RecvPacketData.SN; s_UserID = RecvPacketData.UserID; s_HaveLogin = true;} 非常的清晰，如果命令号为1001，就代表此时为登录包，然后依照官方处理方法，对key进行处理。 1234567891011121314151617181920212223242526272829void PacketProcessor::Logining(PacketData &amp;InPacketData){ if (InPacketData.Body.size() &lt; 4) { return; } // 1. 取尾 4 字节并按“大端”组装 size_t n = InPacketData.Body.size(); uint32_t tail4 = (static_cast&lt;uint32_t&gt;(InPacketData.Body[n - 1])) | (static_cast&lt;uint32_t&gt;(InPacketData.Body[n - 2]) &lt;&lt; 8) | (static_cast&lt;uint32_t&gt;(InPacketData.Body[n - 3]) &lt;&lt; 16) | (static_cast&lt;uint32_t&gt;(InPacketData.Body[n - 4]) &lt;&lt; 24); // 2. 异或 userId uint32_t xorRes = tail4 ^ static_cast&lt;uint32_t&gt;(InPacketData.UserID); // 3. 转为字符串 std::string plain = std::to_string(xorRes); // 4. 计算 MD5 MD5 md5; md5.update(reinterpret_cast&lt;const uint8_t *&gt;(plain.data()), plain.size()); md5.finalize(); std::string md5hex = md5.hexdigest(); // 5. 取前 10 字符作密钥 std::string key = md5hex.substr(0, 10); // 初始化加密算法 Cryptor::InitKey(key);} 然后，我们就得到的关键道具：key。在这之后呢，所有的数据包的解密都会用到key，现在我们可以随意地捕获并解密封包了。 测试登录阶段，可以看到LOGIN_IN指令分别进行了一次发送与一次接收。 尝试移动一下，可以看到PEOPLE_WALK分别被发送和接收了一次，至于日志中为什么是两次，因为第一次没截好图。 那么到这里，封包解密基本结束了，下面进入第二阶段： “对战信息捕获与UI展示” 这部分就自行研究吧！ 最后本文仅用于技术研究与学习交流，请勿用于任何商业用途。 所有相关资源版权归上海淘米网络科技有限公司所有。 如因滥用本文造成法律纠纷，责任由使用者自行承担。 本文参考自赛尔号：通信协议逆向与模拟&amp;中间人攻击窃取登录凭证 联系方式 邮箱：584485321@qq.com 那么最后，赛尔号见！！！","link":"/2025/07/03/game-reversing/network-protocol-reversing/"},{"title":"Java Stream","text":"Stream概述Stream是Java8中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂查找、过滤和映射数据等操作。我们通常借助Stream API对集合数据进行操作。 简单说一下使用Stream时会发生的步骤： 1获取一个数据源 -&gt; 数据转换 -&gt; 执行操作获取结果 获取一个数据源 Stream本身并不会存储数据，而是对数据源的一种抽象视图，它更像一个管道。许哟啊注意的是，Stream并不会改变原始数据。 这里管道可以如何理解呢？就好比生产线上流动的传送带，Stream负责对这些材料进行加工处理。 12List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);Stream&lt;Integer&gt; stream = list.stream(); // 创建数据源 数据转换 数据转换通常会借助一些中间操作，例如： map：将元素映射为新值。 filter：过滤掉不符合条件的元素。 等等… 1Stream&lt;Integer&gt; NewStream = stream.filter(n -&gt; n % 2 == 0); 执行操作获取结果 Stream的计算是惰性求值的，只有在执行终端操作时才会进行实际计算，例如： collect：收集结果到集合。 forEach：遍历。 等等… 1List&lt;Integer&gt; result = NewStream.collect(Collectors.toList()); Stream使用流的创建操作1、 Stream可以通过Collection创建。 123List&lt;String&gt; list = new ArrayList&lt;&gt;();Stream&lt;String&gt; stream = list.stream(); //获取一个顺序流Stream&lt;String&gt; parallelStream = list.parallelStream(); //获取一个并行流 这里解释一下stream和parallelStream的区别： stream是顺序流，它是依照主线程的顺序对流进行操作。 parallelStream是并行流，依照多线程并行执行的方式对流进行操作，因此不保证顺序。 2、Stream可以通过Array创建。 12int[] array = { 1, 3, 5, 6, 8 };IntStream stream = Arrays.stream(array); 3、Stream可以通过静态方法：of()、iterate()、generate()创建。 1234567Stream&lt;Integer&gt; stream = Stream.of(1, 2, 3, 4, 5, 6);Stream&lt;Integer&gt; stream2 = Stream.iterate(0, (x) -&gt; x + 3).limit(4);stream2.forEach(System.out::println);Stream&lt;Double&gt; stream3 = Stream.generate(Math::random).limit(3);stream3.forEach(System.out::println); 流的中间操作筛选筛选会按照一定规则校验流中的元素，将符合条件的元素提取至新的流中，常见的操作如下： filter()：根据条件过滤。 limit(n)：获取n个元素。 skip(n)：跳过n个元素。 distinct()：去除重复元素。 1234567Stream&lt;Integer&gt; stream = Stream.of(6, 4, 6, 7, 3, 9, 8, 10, 12, 14, 14);Stream&lt;Integer&gt; newStream = stream.filter(s -&gt; s &gt; 5) // 6 6 7 9 8 10 12 14 14 .distinct() // 6 7 9 8 10 12 14 .skip(2) // 9 8 10 12 14 .limit(2); // 9 8newStream.forEach(System.out::println); 映射映射可以将一个流的元素按照一定的映射规则映射到另一个流中。分为map和flatMap map：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。 flatMap：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。 12345678910111213List&lt;String&gt; list = Arrays.asList(&quot;a,b,c&quot;, &quot;1,2,3&quot;); //将每个元素转成一个新的且不带逗号的元素Stream&lt;String&gt; s1 = list.stream().map(s -&gt; s.replaceAll(&quot;,&quot;, &quot;&quot;));s1.forEach(System.out::println); // abc 123 Stream&lt;String&gt; s3 = list.stream().flatMap(s -&gt; {//将每个元素转换成一个streamString[] split = s.split(&quot;,&quot;);Stream&lt;String&gt; s2 = Arrays.stream(split);return s2;});s3.forEach(System.out::println); // a b c 1 2 3 流的终止操作遍历12Stream&lt;Integer&gt; stream = Stream.of(6, 4, 6, 7, 3, 9, 8, 10, 12, 14, 14);stream.forEach(System.out::println); 匹配Stream中的元素是以Optional类型存在的。 1234567List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6);Optional&lt;Integer&gt; findFirst = list.stream().filter(x -&gt; x &gt; 3).findFirst();Optional&lt;Integer&gt; findAny = list.parallelStream().filter(x -&gt; x &gt; 3).findAny();System.out.println(&quot;匹配第一个值：&quot; + findFirst.get());System.out.println(&quot;匹配任意一个值：&quot; + findAny.get()); 输出结果为 12匹配第一个值：4匹配任意一个值：4 归约 reduce通常分为三类： Optional reduce1Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator) 第一次执行时，accumulator函数的第一个参数为流中的第一个元素，第二个参数为流中元素的第二个元素；第二次执行时，第一个参数为第一次函数执行的结果，第二个参数为流中的第三个元素；依次类推。 示例： 1234567List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);// 求和Optional&lt;Integer&gt; sum = list.stream() .reduce((a, b) -&gt; a + b);System.out.println(sum.get()); // 输出 15 T reduce1T reduce(T identity, BinaryOperator&lt;T&gt; accumulator) 流程基本一致，不过第一次执行时，accumulator函数的第一个参数为identity，而第二个参数为流中的第一个元素。 1234567List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);// 带初始值的求和int sum = list.stream() .reduce(0, (a, b) -&gt; a + b);System.out.println(sum); // 输出 15 U reduce1&lt;U&gt; U reduce(U identity, BiFunction&lt;U,? super T,U&gt; accumulator, BinaryOperator&lt;U&gt; combiner) 主要用于并行流，我们知道并行流中数据会被拆分给多个线程进行执行，此时每个线程的处理流程会按照T reduce执行；第三个参数combiner，会将每个线程的执行结果当成一个新的流，然后使用第一个方法reduce(accumulator)流程进行归约。 收集 Collector顾名思义，Collector的职责就是将流中的数据重新归集到一起。 这里以toList()为例： 123Stream&lt;Integer&gt; stream = Stream.of(6, 4, 6, 7, 3, 9, 8, 10, 12, 14, 14);List&lt;Integer&gt; list = stream.collect(Collectors.toList());list.forEach(System.out::println); 查看collect方法声明： 12&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector); 再根据下方toList()返回值类型可以知道当前stream.collect()的返回类型是List&lt;T&gt;。 12345public static &lt;T&gt;Collector&lt;T, ?, List&lt;T&gt;&gt; toList() { return new CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::new, List::add, (left, right) -&gt; { left.addAll(right); return left; }, CH_ID); 可以看到toList()返回值类型为Collector&lt;T, ?, List&lt;T&gt;&gt;，CollectorImpl实现了接口Collector&lt;T, A, R&gt;。 1static class CollectorImpl&lt;T, A, R&gt; implements Collector&lt;T, A, R&gt; CollectorImpl实现如下： 123456CollectorImpl(Supplier&lt;A&gt; supplier, BiConsumer&lt;A, T&gt; accumulator, BinaryOperator&lt;A&gt; combiner, Set&lt;Characteristics&gt; characteristics) { this(supplier, accumulator, combiner, castingIdentity(), characteristics);} supplier：空的累加器。 accumulator：累加操作。 combiner：合并操作。 characteristics：收集器特性。","link":"/2025/08/24/Java/Java-Stream/"}],"tags":[],"categories":[{"name":"赛尔号逆向","slug":"赛尔号逆向","link":"/categories/%E8%B5%9B%E5%B0%94%E5%8F%B7%E9%80%86%E5%90%91/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Java8 新特性","slug":"Java/Java8-新特性","link":"/categories/Java/Java8-%E6%96%B0%E7%89%B9%E6%80%A7/"}],"pages":[]}